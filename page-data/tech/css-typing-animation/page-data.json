{"componentChunkName":"component---src-templates-post-tsx","path":"/tech/css-typing-animation","result":{"data":{"markdownRemark":{"html":"<blockquote>\n<p>如果程式碼也會自己出現就好了...</p>\n</blockquote>\n<!-- more -->\n<p>今天來點輕鬆的。</p>\n<p>前陣子看了某個面試者的履歷網站，封面有個打字的動畫效果，雖然以前也很常看到，但沒有實際用 CSS 來實作過，只有在 CSS SECRETS 上看過做法，趁著心血來潮就來玩玩吧！</p>\n<h2 id=\"主要概念\" style=\"position:relative;\"><a href=\"#%E4%B8%BB%E8%A6%81%E6%A6%82%E5%BF%B5\" aria-label=\"主要概念 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>主要概念</h2>\n<p>要有打字效果的動畫，主要就是必須讓文字一個一個出現，因此我們可以利用 <code class=\"language-text\">overflow</code> 與調整包含文字的元素寬度，來達到這個效果。</p>\n<div class=\"gatsby-highlight\" data-language=\"htmlindex.html\"><pre class=\"language-htmlindex.html\"><code class=\"language-htmlindex.html\">&lt;h1&gt; 我要成為神奇寶貝大師！ &lt;/h1&gt;</code></pre></div>\n<hr>\n<div class=\"gatsby-highlight\" data-language=\"csstyping.css\"><pre class=\"language-csstyping.css\"><code class=\"language-csstyping.css\">@keyframes typing {\n  from { width: 0 }\n}\n\nh1 {\n  width: 11em;\n  overflow: hidden;\n  animation: typing 6s;\n}</code></pre></div>\n<p>這邊的文字寬度，要去算你包含文字的那個元素所設定的 <code class=\"language-text\">font-size</code>，並乘上你的字數。</p>\n<p>出來的結果如下：</p>\n<p><img src=\"/image/typing1.gif\" alt=\"Typing1\" title=\"Typing1\"></p>\n<p>搞啥啊！這什麼鬼 XD</p>\n<p>兩個問題：</p>\n<ol>\n<li>寬度會影響行數，就算 <code class=\"language-text\">overflow: hidden</code>，文字會折行這件事情並不會消失。</li>\n<li>文字並沒有真正的逐格出現</li>\n</ol>\n<h2 id=\"solution\" style=\"position:relative;\"><a href=\"#solution\" aria-label=\"solution permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Solution</h2>\n<p>第一個問題好解決，我們可以加上 <code class=\"language-text\">white-space: nowrap</code>。\n第二個問題就必須借助 CSS 中 animation 的一個屬性值：<code class=\"language-text\">steps()</code></p>\n<p>通常我們在用 CSS 的 animatin 時，多數會使用 linear, ease-in-out, cubic-bezier 等等的 Speed Curve，這些依照貝茲曲線為主的函式會在關鍵影格中間插入<strong>過渡動畫</strong>，在一般的使用場景中非常適用，畢竟沒人想要讓動畫看起來卡卡的。</p>\n<p>但是在打字動畫中，我們就是需要讓動畫看起來卡卡的 XD</p>\n<p>所以我們可以利用這個較少人討論的 <code class=\"language-text\">steps()</code> 函式來實作。</p>\n<p><code class=\"language-text\">steps()</code> 會根據你輸入的步驟數，用影格切割動畫，不補入過渡動畫。</p>\n<p>我們調整剛剛的 CSS 如下：</p>\n<hr>\n<div class=\"gatsby-highlight\" data-language=\"csstyping.css\"><pre class=\"language-csstyping.css\"><code class=\"language-csstyping.css\">@keyframes typing {\n  from { width: 0 }\n}\n\nh1 {\n  width: 11em;\n  overflow: hidden;\n  white-space: nowrap;\n  animation: typing 3s steps(11)\n}</code></pre></div>\n<p><img src=\"/image/typing2.gif\" alt=\"沒有換行，且一格一格出現文字\" title=\"沒有換行，且一格一格出現文字\"></p>\n<h2 id=\"enhancement\" style=\"position:relative;\"><a href=\"#enhancement\" aria-label=\"enhancement permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Enhancement</h2>\n<p>但既然是打字，沒有游標怎麼可以。來加強一下。</p>\n<p>閃爍游標的做法很多種，這邊我們採取最簡單的方式，由於我們是利用<strong>調整</strong>元素寬度去控制文字出現，因此可以直接加入一個右邊框，並調整其 transparent。</p>\n<div class=\"gatsby-highlight\" data-language=\"csstyping.css\"><pre class=\"language-csstyping.css\"><code class=\"language-csstyping.css\">@keyframes caret {\n  50% { border-color: transparent; }\n}\n\nh1 {\n  width: 11em;\n  border-right: .05em solid;\n  overflow: hidden;\n  white-space: nowrap;\n  animation: typing 3s steps(11),\n    caret 1s steps(1) infinite;\n}</code></pre></div>\n<p><img src=\"/image/typing3.gif\" alt=\"加入閃爍游標\" title=\"最終結果\"></p>\n<p>短短五分鐘，純 CSS 的打字效果動畫就出來囉！</p>\n<p>Live 範例：</p>\n<div class=\"inputField\">\n  <h3>皮卡丘！就決定是你了！</h3>\n</div>\n<style>\n@keyframes caret {\n  50% { border-color: transparent; }\n}\n@keyframes typing {\n  from { width: 0 }\n}\n<p>.inputField {\npadding: 20px;\nborder: 1px solid black;\n}</p>\n<p>h3 {\nwidth: 11em;\nborder-right: .05em solid;\noverflow: hidden;\nwhite-space: nowrap;\nanimation: typing 3s steps(11) infinite,\ncaret 1s steps(1) infinite;\n}\n</style></p>","fields":{"slug":"css-typing-animation"},"frontmatter":{"title":"快速實作 CSS3 打字動畫","date":"08-06-2016","tags":["css","javascript"]},"timeToRead":2}},"pageContext":{"slug":"css-typing-animation","prev":{"excerpt":"\"所以你是說...我手機上會有我上傳到平台的資料？\"\n\"是的\"\n\"可是它顯示 0kb 呀？！\"","html":"<blockquote>\n<p>\"所以你是說...我手機上會有我上傳到平台的資料？\"\n\"是的\"\n\"可是它顯示 0kb 呀？！\"</p>\n</blockquote>\n<!-- more -->\n<p>距離今年 Google I/O 2016 轉眼間也過了兩個多月，議程中提及的 Progressive Web App (PWA) 似乎討論不多，我當時隨便掃過 Google Developers 上的資料後的念頭是：“怎麼有點像當年 Firefox OS 上跑 web app的長相？”</p>\n<p>其實我覺得是蠻雷同的，差別在於 Progressive Web App 是想能夠直接利用目前的 Browser 來支援其運作。實際上 Mozilla 一樣有在推動相關標準的建立。</p>\n<p>這也是我初次接觸 Progressive Web App，因此就照著 Google Developers 上的教學走一遍，並紀錄分享在此。</p>\n<h2 id=\"何謂-progressive-web-app-pwa\" style=\"position:relative;\"><a href=\"#%E4%BD%95%E8%AC%82-progressive-web-app-pwa\" aria-label=\"何謂 progressive web app pwa permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>何謂 Progressive Web App (PWA)</h2>\n<p>先講結論，Progressive Web App 是希望能夠讓 Web application 盡可能的在各種環境（網路環境、手機作業系統等）下都能順暢且不減功能性的運作，並讓你的 Web App 可以：</p>\n<ol>\n<li>直接被使用者安裝到桌面</li>\n<li>offline 使用</li>\n<li>擁有推播功能</li>\n<li>開啟時看不到 URL Bar（類 Native app 的使用經驗）</li>\n<li>開啟時有 Splash Screen</li>\n</ol>\n<p>而要做到這些事情，整個 PWA 的設計要點就會包含以下特性：</p>\n<ul>\n<li><strong><span style=\"color: #c11b1b\">Progressive - 漸進增強：在越完善的環境下，能執行更加完整的服務，若環境不許可，能夠優雅降級，運行最基本的功能。</span></strong></li>\n<li>Responsive - 響應式介面：能夠在各種螢幕尺寸下顯示、能夠因應多種輸入方式與設備回饋（震動、音頻等）。</li>\n<li><strong><span style=\"color: #c11b1b\">App-like - 類原生程式的操作模式與使用者介面：採用原生平台（Native App）的 Style 與資料更新方式（利用 service worker 存取快取資源）。</span></strong></li>\n<li><strong><span style=\"color: #c11b1b\">Fresh - 持續更新：使用 Service worker API 來自動更新應用程式（無需透過 App store, Google Play 等）。</span></strong></li>\n<li>Safe - 應全面採用 HTTPS 提供最基本的安全防護。</li>\n<li>Discoverable - 透過設置 manifest 檔案，一樣能進行 SEO 優化，讓搜尋引擎找得到你的 APP。</li>\n<li><strong><span style=\"color: #c11b1b\">Re-engageable - 透過推播，能主動與使用者互動。</span></strong></li>\n<li><strong><span style=\"color: #c11b1b\">Installable - 可安裝：透過 Add To Home 等方式，將 Web App 放在手機桌面，並且能在應用程式中單獨列出與切換，就像一般的 App 一樣，但完全不用透過應用程式商店下載。</span></strong></li>\n<li>Linkable - 透過 URL 可以隨時分享你的 App。</li>\n</ul>\n<p>上面是官網所列出的，而紅色是我認為較為重點的特徵，而在這些重點特徵下，最大要點就是 Service worker。有了 Service worker 的幫助，你可以實作出離線可用的 Web App，讓 User 操作起來有更佳的使用體驗。</p>\n<!-- 簡介 service worker -->\n<h2 id=\"service-worker\" style=\"position:relative;\"><a href=\"#service-worker\" aria-label=\"service worker permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Service Worker</h2>\n<p>Service worker 是一個運行在瀏覽器背後的腳本，有其自己的生命週期，並獨立於網頁頁面。\n其特性如下：</p>\n<ul>\n<li><strong><span style=\"color: #071684\">Javascript worker，無法直接操作頁面 DOM，但可透過 <code class=\"language-text\">postMessage</code> 與頁面溝通，讓該頁面自行操作 DOM。</span></strong></li>\n<li><strong><span style=\"color: #071684\">Service worker 可以讓你截取並掌控頁面發出的 network request。(這點很重要！要記住！！)</span></strong></li>\n<li><strong><span style=\"color: #071684\">當 Service worker 不需要被使用時，會進入 Terminated 生命週期，等待下一次的需求進來。因此你在 onfetch 或是 onmessage 的 event handler 中若想要儲存全域變數，必須使用 <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">IndexedDB</a> API 來輔助儲存。</span></strong></li>\n<li><strong><span style=\"color: #071684\">使用 Promise (這對一般開發者來說應該已經不算難事)</span></strong></li>\n</ul>\n<p>待會進行 PWA 實作的時候，我們就會運用到 service worker，透過 intercept 以及 handle network requests 來幫忙處理 Cache 的議題。</p>\n<p>今天重點擺在 PWA，Service Worker 的相關介紹可以看這裡：\n<a href=\"http://www.html5rocks.com/en/tutorials/service-worker/introduction/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">source: html5rocks</a>\n<img src=\"/image/sw-lifecycle.png\" alt=\"Service Worker LifeCycle\" style=\"width: 500px;\"/></p>\n<!-- 動手做第一個 pwa -->\n<p>看太多文字會想睡覺，所以開始動手做我們的第一個 Progressive Web App 吧！</p>\n<h1 id=\"progressive-web-app\" style=\"position:relative;\"><a href=\"#progressive-web-app\" aria-label=\"progressive web app permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Progressive Web App</h1>\n<p>為求快速，我們跟著 Google developers 上的範例程式走一遍，才能專注在 PWA 的部分，不用去管其他細節。code 可以在此下載 <a href=\"https://developers.google.com/web/fundamentals/getting-started/your-first-progressive-web-app/pwa-weather.zip\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">google developers pwa example</a>，後續步驟會需要這份 code 來做對應比較方便理解。</p>\n<p>範例是一個天氣卡，可以顯示所選區域的天氣狀況，大致上會長這樣：</p>\n<img src=\"/image/pwa-weather-example-final.png\" alt=\"pwa-weather\" style=\"width: 200px;\"/>\n<h2 id=\"app-shell-architecture\" style=\"position:relative;\"><a href=\"#app-shell-architecture\" aria-label=\"app shell architecture permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>App Shell Architecture</h2>\n<p>當你用瀏覽器打開一個網頁時，通常都需要等該頁面載完需要的 javascript, css 等等檔案後，你才能看到一個完整的頁面，在 SPA 當道的現今更是如此（姑且先不談 server-side render）</p>\n<p>但還記得先前提過，Progressive Web App 的目標是想要能夠 <strong><span style=\"color: #c11b1b\">讓 Web application 盡可能的在各種環境（網路環境、手機作業系統等）下都能順暢且不減功能性的運作。</span></strong></p>\n<p>因此 PWA 提出了一個 <strong>App Shell Architecture</strong></p>\n<p>App shell architecture 將應用程式的基礎設施（infrastructure）、UI 與資料做分離，並利用 service worker 將 infra 與 UI 做 Cache，如此一來，當你重複打開 Web App 時，需要遠端載入的就只剩下資料，因為其他部分都已經先快取在本地端了（也可以把部分資料先快取起來）。</p>\n<p>由上述說明應該不難看出 app shell 的設計會非常重要，他決定了你的 User 進到你的 App 後的第一印象。所以在設計 App shell architecture 時，有幾個要點必須考量清楚：</p>\n<ul>\n<li>當 Web App 開啟時，哪些東西需要立即呈現在螢幕上?</li>\n<li>有哪些是重要的 UI components？</li>\n<li>此 app shell 是否需要 styles, javascript 等等資源？</li>\n</ul>\n<p>以今天的範例來說，我們會預期一開啟 App 時，要能馬上看到最上方的 Header 以及中間至少一張天氣預測卡，因此這兩個元件就會是我們必須設計進 App shell architecture 的 component。</p>\n<p>稍稍整理一下，我們的 App shell 將會擁有：</p>\n<ul>\n<li>顯示 App 名稱、更新與新增按鈕的 Header Bar</li>\n<li>Header 下方放置天氣卡的 Container</li>\n<li>天氣卡模板</li>\n<li>加入地區天氣時的對話筐</li>\n<li>載入狀態的 loader</li>\n</ul>\n<h2 id=\"app-shell-architecture-implementation\" style=\"position:relative;\"><a href=\"#app-shell-architecture-implementation\" aria-label=\"app shell architecture implementation permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>App shell architecture implementation</h2>\n<p>根據上方列出的需求，身為 web developer 一定很快就會把 HTML、CSS 刻好，甚至將可能需要的 JS 都先準備好，但實際上 Progressive web app 的重點其實在於如何將元件與資料做 cache ，以及 app-like 的顯示模式，因此我們跳過這些跟基礎 web 開發相關的步驟，直接到剛剛下載的範例檔案中，打開 step-04 資料夾，裡面就有了最 default 的元件 layout（<code class=\"language-text\">index.html</code>, <code class=\"language-text\">inline.cs</code>），以及資料 fetch 相關的 javascript 檔案（<code class=\"language-text\">app.js</code>）：</p>\n<img src=\"/image/step-04-foldr.png\" alt=\"step-04 folder\" style=\"width: 200px;\"/>\n<p><strong><span style=\"color: #c11b1b\">[!NOTICE] 需要將程式碼內的一些相關路徑修改一下才能正常運作喔！</span></strong></p>\n<p>開啟以後正常會看到如下畫面：</p>\n<p><img src=\"/image/step-04.gif\" alt=\"step-04\" title=\"step-04\"></p>\n<p>會先閃過 loading 圈圈，接著利用 <code class=\"language-text\">initialWeatherForecast</code> 做第一次資料繪製，這邊是先寫死一個假資料，但實務上應該要根據 user 當下 ip location 去抓取資料並更新。</p>\n<p>但不管是假資料與否，重點在於，當處理完第一次資料 fetch 後，要能夠 cache 起來，才能應付 slow connection 或是 offline 的狀況。也就是待會 service-worker 要負責的事情。</p>\n<p>此外，此 Wep app的功能中，要<strong>讓 user 能夠選擇想要的區域</strong>，我們總不能要 user 每次進來都重選，因此要能儲存這部分資訊，實務上可以用 <code class=\"language-text\">IndexDB</code> 來儲存，Google 推薦的 lib 為 <a href=\"https://www.npmjs.com/package/idb\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">idb</a>，而這邊我們簡單用 LocalStorage API 來處理即可。</p>\n<p>相關設定在 <code class=\"language-text\">app.js</code> 當中：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsapp.js\"><pre class=\"language-jsapp.js\"><code class=\"language-jsapp.js\"> // Iterate all of the cards and attempt to get the latest forecast data\n  app.updateForecasts = function() {\n    var keys = Object.keys(app.visibleCards);\n    keys.forEach(function(key) {\n      app.getForecast(key);\n    });\n  };\n\n  // Save list of cities to localStorage, see note below about localStorage.\n  app.saveSelectedCities = function() {\n    var selectedCities = JSON.stringify(app.selectedCities);\n    // IMPORTANT: See notes about use of localStorage.\n    localStorage.selectedCities = selectedCities;\n  };\n\n  app.selectedCities = localStorage.selectedCities;\n  if (app.selectedCities) {\n    app.selectedCities = JSON.parse(app.selectedCities);\n    app.selectedCities.forEach(function(city) {\n      app.getForecast(city.key, city.label);\n    });\n  } else {\n    app.updateForecastCard(initialWeatherForecast);\n    app.selectedCities = [\n      {key: initialWeatherForecast.key, label: initialWeatherForecast.label}\n    ];\n    app.saveSelectedCities();\n  }</code></pre></div>\n<p>如此一來，你可以新增想要的城市，在當你重新載入時，就會看到剛剛所選的城市依然會出現了。</p>\n<p><img src=\"/image/localstorage.gif\" alt=\"localstorage\" title=\"local storage test\"></p>\n<h2 id=\"use-service-worker-to-pre-cache-the-app-shell\" style=\"position:relative;\"><a href=\"#use-service-worker-to-pre-cache-the-app-shell\" aria-label=\"use service worker to pre cache the app shell permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Use Service Worker to Pre-cache the App Shell</h2>\n<h3 id=\"前情提要\" style=\"position:relative;\"><a href=\"#%E5%89%8D%E6%83%85%E6%8F%90%E8%A6%81\" aria-label=\"前情提要 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>前情提要</h3>\n<p><strong><span style=\"color: #c11b1b\">Service worker 的功能只能在 localhost 或是 HTTPS 的環境下，並且目前的瀏覽器有支援的不多，至少要 Chrome 47 以上。不過相信會越來越多瀏覽器加入此支援的。</span></strong></p>\n<h3 id=\"step-1-註冊-service-worker\" style=\"position:relative;\"><a href=\"#step-1-%E8%A8%BB%E5%86%8A-service-worker\" aria-label=\"step 1 註冊 service worker permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>step 1. 註冊 <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">service worker</a></h3>\n<p>在我們的 <code class=\"language-text\">app.js</code> 中，需要先檢查是否有 service worker 存在，若無，則透過 <code class=\"language-text\">navigator.serviceWorker</code> 去註冊。</p>\n<div class=\"gatsby-highlight\" data-language=\"jsapp.js\"><pre class=\"language-jsapp.js\"><code class=\"language-jsapp.js\">if(&#39;serviceWorker&#39; in navigator) {  \n  navigator.serviceWorker  \n           .register(&#39;/service-worker.js&#39;)  \n           .then(function() { console.log(&#39;Service Worker Registered&#39;); });  \n}</code></pre></div>\n<p>當然，我們也要創建好我們的 <code class=\"language-text\">service-worker.js</code>。 Service worker 的檔案要放在<strong>根目錄</strong>底下，因為 service worker 的 js scope 是包含其所在之目錄。</p>\n<h3 id=\"step-2-pre-cache-assets\" style=\"position:relative;\"><a href=\"#step-2-pre-cache-assets\" aria-label=\"step 2 pre cache assets permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>step 2. Pre-cache assets</h3>\n<p>當 service worker 被註冊好後，當使用者初次開啟我們的 web app，會觸發一個 <code class=\"language-text\">install</code> event，而我們可以在這個 event handler 中 cache 住我們需要的 assets。</p>\n<div class=\"gatsby-highlight\" data-language=\"jsservice-worker.js\"><pre class=\"language-jsservice-worker.js\"><code class=\"language-jsservice-worker.js\">self.addEventListener(&#39;install&#39;, function(e) {\n  console.log(&#39;[ServiceWorker] Install&#39;);\n  e.waitUntil(\n    caches.open(cacheName).then(function(cache) {\n      console.log(&#39;[ServiceWorker] Caching App Shell&#39;);\n      return cache.addAll(filesToCache);\n    })\n  );\n});</code></pre></div>\n<p><strong>其中的 caches 是 Service Worker API 中的 <code class=\"language-text\">CacheStorage</code>，可以到 <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/CacheStorage/open\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">MDN</a> 瞭解一下。</strong></p>\n<p>此外，<code class=\"language-text\">chacheName</code> 的設定也是蠻重要的，可以依此來分開你的資料與 App shell 的快取。</p>\n<p>當你 <code class=\"language-text\">caches.open</code>後，裡面的 callback 可以呼叫 <code class=\"language-text\">cache.addAll()</code> 來將 assets 放入快取，<code class=\"language-text\">cache.addAll()</code> 接受 <code class=\"language-text\">URL</code> list，像是這樣的格式：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsservice-worker.js\"><pre class=\"language-jsservice-worker.js\"><code class=\"language-jsservice-worker.js\">var filesToCache = [  \n  &#39;/&#39;,  \n  &#39;/index.html&#39;,  \n  &#39;/scripts/app.js&#39;,  \n  &#39;/styles/inline.css&#39;,  \n  &#39;/images/clear.png&#39;,  \n  &#39;/images/cloudy-scattered-showers.png&#39;,  \n  &#39;/images/cloudy.png&#39;,  \n  &#39;/images/fog.png&#39;,  \n  &#39;/images/ic\\_add\\_white\\_24px.svg&#39;,  \n  &#39;/images/ic\\_refresh\\_white\\_24px.svg&#39;,  \n  &#39;/images/partly-cloudy.png&#39;,  \n  &#39;/images/rain.png&#39;,  \n  &#39;/images/scattered-showers.png&#39;,  \n  &#39;/images/sleet.png&#39;,  \n  &#39;/images/snow.png&#39;,  \n  &#39;/images/thunderstorm.png&#39;,  \n  &#39;/images/wind.png&#39;  \n];</code></pre></div>\n<p>建議你加入版號來設置你的 <code class=\"language-text\">cachName</code>，這樣才能確保每次更新都能拿到最新資料。不過要記得將過期的 cache 清空！\n我們可以在 <code class=\"language-text\">activate</code> 這個 event 的 handler 來做這件事情。</p>\n<div class=\"gatsby-highlight\" data-language=\"jsservice-worker.js\"><pre class=\"language-jsservice-worker.js\"><code class=\"language-jsservice-worker.js\">self.addEventListener(&#39;activate&#39;, function(e) {  \n  console.log(&#39;[ServiceWorker] Activate&#39;);  \n  e.waitUntil(  \n    caches.keys().then(function(keyList) {  \n      return Promise.all(keyList.map(function(key) {  \n        console.log(&#39;[ServiceWorker] Removing old cache&#39;, key);  \n        if (key !== cacheName) {  \n          return caches.delete(key);  \n        }  \n      }));  \n    })  \n  );  \n});</code></pre></div>\n<h3 id=\"step-3-fetch-assets-from-cache-or-not\" style=\"position:relative;\"><a href=\"#step-3-fetch-assets-from-cache-or-not\" aria-label=\"step 3 fetch assets from cache or not permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>step 3. Fetch assets from cache or not</h3>\n<p>到目前為止，我們知道了怎麼把 assets 存進 cache 裡面，但要怎麼拿出來呢？\n我們註冊一個 <code class=\"language-text\">fetch</code> event handler，用來擷取 web app 發出的 request，當 request 有 match 到我們剛剛存入的那些 assets 時，我們就從中取出並回傳，若並沒有 match 到，則利用 <code class=\"language-text\">fetch</code> api 去真的打 request。 [ fetch api 也是目前實驗中的 web api，介紹可看 <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Fetch api</a> ]</p>\n<div class=\"gatsby-highlight\" data-language=\"jsservice-worker.js\"><pre class=\"language-jsservice-worker.js\"><code class=\"language-jsservice-worker.js\">self.addEventListener(&#39;fetch&#39;, function(e) {  \n  console.log(&#39;[ServiceWorker] Fetch&#39;, e.request.url);  \n  e.respondWith(  \n    caches.match(e.request).then(function(response) {  \n      return response || fetch(e.request);  \n    })  \n  );  \n});</code></pre></div>\n<h3 id=\"beware-of-the-edge-cases\" style=\"position:relative;\"><a href=\"#beware-of-the-edge-cases\" aria-label=\"beware of the edge cases permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Beware of the edge cases</h3>\n<p>目前範例中的 code 實際上並不適合運用在 production 上頭，因為有許多 edge cases 沒有被考慮與處理到：</p>\n<ol>\n<li>剛剛提過的，當你的 content 有變動時，cache key 要更新（範例內我們需要手動更新）。</li>\n<li>只要你的檔案有一點點更動，小至 typo，大至 code refactor，都會造成 cache invalidated，需要重新下載，效率不好。</li>\n<li>必須確保 service-worker 中的 <code class=\"language-text\">install handler</code> 所發出的 https request 不會被 Brower cache 影響，否則會無法 update。</li>\n<li>最重要的一點，範例採用 cache-first 的策略，任何 request 只要有 cache 在就會先拿 cache，若 service worker 相關的註冊與設定也被 cache 時，更新會變得很困難。</li>\n</ol>\n<p>Google 提出一套 lib <a href=\"https://github.com/GoogleChrome/sw-precache\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">sw-precache</a> 來幫助你避免上述的 edge cases，這超出此篇的範疇，但若要製作 Productoin 版本的 PWA 時，務必研究一下。</p>\n<p>此外，在開發中，也可以透過 <code class=\"language-text\">chrome://serviceworker-internals</code> 來 stop、un-register 現存的 service workers 以及 fresh start service worker。</p>\n<h3 id=\"test-service-worker\" style=\"position:relative;\"><a href=\"#test-service-worker\" aria-label=\"test service worker permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Test Service worker</h3>\n<p>現在我們可以來試試看剛剛的 service worker 到底能不能幫我們把 assets cache 起來，你可以像 Google 教學中 deploy 到 <a href=\"https://developers.google.com/web/fundamentals/getting-started/your-first-progressive-web-app/step-08?hl=en\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">firebase</a>，也可以學我直接用 express 來 host。</p>\n<p>用 express 來 host 範例需要更動幾個地方：</p>\n<ol>\n<li>把範例的 index.html, inline.css, app.js 和一些 images 放入 express 中的相對路徑。</li>\n<li>修改 service-worker.js 中的 <code class=\"language-text\">filesToCache</code> 相對路徑，主要是 app.js 與 inline.css</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"jsservice-worker-in-express.js\"><pre class=\"language-jsservice-worker-in-express.js\"><code class=\"language-jsservice-worker-in-express.js\">var filesToCache = [\n  &#39;/&#39;,\n  &#39;/javascripts/app.js&#39;,\n  &#39;/stylesheets/inline.css&#39;,\n  &#39;...&#39;,\n  &#39;..&#39;</code></pre></div>\n<p>啟動server 後，開啟 Chrome devTool 的 resources tab，應該可以看到如下畫面，就代表你的 service worker 有成功幫你 cache 住 assets：</p>\n<p><img src=\"/image/cache-example.png\" alt=\"service-worker cache\" title=\"service-worker cache\"></p>\n<h3 id=\"step-4-cache-data\" style=\"position:relative;\"><a href=\"#step-4-cache-data\" aria-label=\"step 4 cache data permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>step 4. Cache Data</h3>\n<p>接下來我們要 cache 住資料！</p>\n<p>策略上分兩種：</p>\n<ol>\n<li>cache first then network：一次發兩種 request，先抓 cache 資料，等 network request 回來後更新 cache。</li>\n<li>network first then cache：先發 network request，若 timeout 再撈 cache 資料。</li>\n</ol>\n<p>這邊我們採用 cache-first，才能因應快速 response 與 offline 使用的需求。</p>\n<p>首先我們得在 service-worker 中加入一個 <code class=\"language-text\">dataCacheName</code>，用以區分資料與 app shell 的 cache。</p>\n<div class=\"gatsby-highlight\" data-language=\"jsservice-worker.js\"><pre class=\"language-jsservice-worker.js\"><code class=\"language-jsservice-worker.js\">var dataCacheName = &#39;weatherData-v1&#39;;</code></pre></div>\n<p>接著在 <code class=\"language-text\">fetch</code> event handler 中，我們將抓取資料的API request 與其他 request 分開。</p>\n<div class=\"gatsby-highlight\" data-language=\"jsservice-worker.js\"><pre class=\"language-jsservice-worker.js\"><code class=\"language-jsservice-worker.js\">self.addEventListener(&#39;fetch&#39;, function(e) {  \n  console.log(&#39;[ServiceWorker] Fetch&#39;, e.request.url);  \n  var dataUrl = &#39;https://publicdata-weather.firebaseio.com/&#39;;  \n  if (e.request.url.indexOf(dataUrl) === 0) {  \n    // Put data handler code here  \n  } else {  \n    e.respondWith(  \n      caches.match(e.request).then(function(response) {  \n        return response || fetch(e.request);  \n      })  \n    );  \n  }  \n});</code></pre></div>\n<p>上面的 code 中，service-worker 會擷取頁面發出的 request，如果包含 dataUrl，我們就另外處理：</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\">e<span class=\"token punctuation\">.</span><span class=\"token function\">respondWith</span><span class=\"token punctuation\">(</span>  \n  <span class=\"token function\">fetch</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">.</span>request<span class=\"token punctuation\">)</span>  \n    <span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">response</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>  \n      <span class=\"token keyword\">return</span> caches<span class=\"token punctuation\">.</span><span class=\"token function\">open</span><span class=\"token punctuation\">(</span>dataCacheName<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">cache</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>  \n        cache<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">.</span>request<span class=\"token punctuation\">.</span>url<span class=\"token punctuation\">,</span> response<span class=\"token punctuation\">.</span><span class=\"token function\">clone</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  \n        console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'[ServiceWorker] Fetched&amp;Cached Data'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  \n        <span class=\"token keyword\">return</span> response<span class=\"token punctuation\">;</span>  \n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  \n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>  \n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>利用 <code class=\"language-text\">fetch API</code> 發送 request，送回來的 response 再傳回去之前，會先 clone 一份到 cache 當中。</p>\n<p>到這邊為止我們 cache 住資料了，但還是不能 offline 運作！因為還少了一個步驟，先前提到我們要同步發送 <strong>兩個</strong> request，一個抓 cache，一個真的送資料。</p>\n<p>在 <code class=\"language-text\">app.js</code> 中的 <code class=\"language-text\">app.getForecast</code>裡加入這段：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsapp.js\"><pre class=\"language-jsapp.js\"><code class=\"language-jsapp.js\">if (&#39;caches&#39; in window) {\n  caches.match(url).then(function(response) {\n    if (response) {\n      response.json().then(function(json) {\n        // Only update if the XHR is still pending, otherwise the XHR\n        // has already returned and provided the latest data.\n        if (app.hasRequestPending) {\n          console.log(&#39;[App] Forecast Updated From Cache&#39;);\n          json.key = key;\n          json.label = label;\n          app.updateForecastCard(json);\n        }\n      });\n    }\n  });\n}</code></pre></div>\n<p>先檢查 <code class=\"language-text\">window</code> 有無支援 <code class=\"language-text\">caches</code> object，接著從 caches 中拿出資料，這時要確認一下同時發送出去的 network request 是否已經 response 回來了，我們這邊用個 flag <code class=\"language-text\">app.hasRequestPending</code> 來控制。只有在 network response 還沒回來前我們會使用 caches 內的資料。</p>\n<p>而在發送原本的 <code class=\"language-text\">XMLHttpRequest</code> 之前，記得加上 <code class=\"language-text\">app.hasRequestPending = true;</code>，並在 <code class=\"language-text\">app.updateForecastCard(response)</code>之前，將 <code class=\"language-text\">app.hasRequestPending</code> 設為 false。</p>\n<h3 id=\"test-offline-function\" style=\"position:relative;\"><a href=\"#test-offline-function\" aria-label=\"test offline function permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Test Offline function</h3>\n<p>到目前為止我們的 Web app 已經可以在 offline 使用了，即便遠端 host 掛掉，我們能從 cache 中抓到我們的 App Shell，並且透過 service worker 幫我們去跟 <code class=\"language-text\">https://publicdata-weather.firebaseio.com/</code> 要資料；若是連網路都沒有，至少會有 cache 的資料可以顯示！</p>\n<p><img src=\"/image/offline-1.gif\" alt=\"offline test I- without host server\" title=\"offline test\"></p>\n<p><img src=\"/image/offlinetest-2.gif\" alt=\"offline test II - without network connection\" title=\"offline test\"></p>\n<h2 id=\"support-native-integration\" style=\"position:relative;\"><a href=\"#support-native-integration\" aria-label=\"support native integration permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Support Native Integration</h2>\n<p>Progressive Web App 的最後一哩路，我們要加入 Add-to-Homescreen。</p>\n<p>要有 Add to Homescreen 的功能不難，只要加入一個 manifest.json 即可，透過這方式打開的 Web App 不會顯示出 URL bar，看起來就像一般的 App！你也可以再加入 Web app install banners，這邊就不討論，可以看這篇的教學 - <a href=\"https://developers.google.com/web/fundamentals/engage-and-retain/app-install-banners/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Web app install banners</a></p>\n<h3 id=\"web-app-manifest\" style=\"position:relative;\"><a href=\"#web-app-manifest\" aria-label=\"web app manifest permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Web App Manifest</h3>\n<p>透過 web app manifest，你可以：</p>\n<ul>\n<li>像 App 一般有個漂亮 icon 顯現在 Android 的 Homescreen 上。</li>\n<li>開啟時可以進入全螢幕畫面，不顯示 URL bar！</li>\n<li>控制 screen orientation。</li>\n<li>設定 <code class=\"language-text\">splash screen</code>，以前是為了降低 User 等待載入時間，但現在通常都用來宣傳你的網站品牌等等（有些人是不推薦使用...）</li>\n<li>追蹤你的 App 是從 homescreen 還是 url 開啟。</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"jsonmanifets.json\"><pre class=\"language-jsonmanifets.json\"><code class=\"language-jsonmanifets.json\">{\n  &quot;name&quot;: &quot;Weather&quot;,\n  &quot;short_name&quot;: &quot;Weather&quot;,\n  &quot;icons&quot;: [{\n    &quot;src&quot;: &quot;images/icons/icon-128x128.png&quot;,\n      &quot;sizes&quot;: &quot;128x128&quot;,\n      &quot;type&quot;: &quot;image/png&quot;\n    }, {\n      &quot;src&quot;: &quot;images/icons/icon-144x144.png&quot;,\n      &quot;sizes&quot;: &quot;144x144&quot;,\n      &quot;type&quot;: &quot;image/png&quot;\n    }, {\n      &quot;src&quot;: &quot;images/icons/icon-152x152.png&quot;,\n      &quot;sizes&quot;: &quot;152x152&quot;,\n      &quot;type&quot;: &quot;image/png&quot;\n    }, {\n      &quot;src&quot;: &quot;images/touch/icon-192x192.png&quot;,\n      &quot;sizes&quot;: &quot;192x192&quot;,\n      &quot;type&quot;: &quot;image/png&quot;\n    }, {\n      &quot;src&quot;: &quot;images/touch/icon-256x256.png&quot;,\n      &quot;sizes&quot;: &quot;256x256&quot;,\n      &quot;type&quot;: &quot;image/png&quot;\n    }],\n  &quot;start_url&quot;: &quot;/&quot;,\n  &quot;display&quot;: &quot;standalone&quot;,\n  &quot;background_color&quot;: &quot;#3E4EB8&quot;,\n  &quot;theme_color&quot;: &quot;#2F3BA2&quot;\n}</code></pre></div>\n<p>[小技巧] 可以透過在 <code class=\"language-text\">start_url</code> 設置 query string 的參數來追蹤開啟來源。</p>\n<p>manifest 檔案設定好後記得回到你的 <code class=\"language-text\">index.html</code> 的 <code class=\"language-text\">&lt;head></code> 加上 <code class=\"language-text\">&lt;link rel=\"manifest\" href=\"/manifest.json\"></code></p>\n<h3 id=\"for-safari-in-ios\" style=\"position:relative;\"><a href=\"#for-safari-in-ios\" aria-label=\"for safari in ios permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>for safari in ios</h3>\n<p>如果要用在 ios 上的 safari 還需要額外設定</p>\n<div class=\"gatsby-highlight\" data-language=\"html\"><pre class=\"language-html\"><code class=\"language-html\"><span class=\"token comment\">&lt;!-- Add to home screen for Safari on iOS --></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>meta</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>apple-mobile-web-app-capable<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">content</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>yes<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>meta</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>apple-mobile-web-app-status-bar-style<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">content</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>black<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>meta</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>apple-mobile-web-app-title<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">content</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>Weather App<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>link</span> <span class=\"token attr-name\">rel</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>apple-touch-icon<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">href</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>images/icons/icon-152x152.png<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span></code></pre></div>\n<h3 id=\"best-practices\" style=\"position:relative;\"><a href=\"#best-practices\" aria-label=\"best practices permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Best practices</h3>\n<ul>\n<li>在你網站的每個 page 都可放入 manifest.json，這樣不管 user 是從哪頁進去，Chrome都能偵測到</li>\n<li><code class=\"language-text\">short_name</code> 盡量都要設置，優先權高於 <code class=\"language-text\">name</code> 這個 field。</li>\n<li>icon 的大小要盡可能符合多種 device。</li>\n<li>icon 也要考量到是否符合 slash screen，並記得設置 <code class=\"language-text\">background_color</code></li>\n</ul>\n<h2 id=\"final\" style=\"position:relative;\"><a href=\"#final\" aria-label=\"final permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Final</h2>\n<p>最終到你手機上的呈現就會像這樣：</p>\n<p>IOS 版本 (ISO 版本看不到 splash screen，不確定原因，可能版本不支援）：</p>\n<img src=\"/image/iphoneDemo_1.gif\" alt=\"iphone demo\" style=\"width: 400px;\">\n<p>Android 版本（主要是看得到 splash screen..）：</p>\n<img src=\"/image/android-1.jpg\" alt=\"android demo\" style=\"width: 300px;\"/>\n<h2 id=\"結論\" style=\"position:relative;\"><a href=\"#%E7%B5%90%E8%AB%96\" aria-label=\"結論 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>結論</h2>\n<p>看了今年 Google I/O 與 Apple WWDC 後，Apple 感覺想把 App 更融入他們的系統，以後或許不會再有 App 的概念，就是 Apple。而 Google 則持續推廣 Progressive Web App，希望讓 Web 能夠更行動化，似乎都希望能夠弭平一些隔閡。</p>\n<p>我個人是蠻希望 Progressive Web App 的方式能普及，可惜現在的瀏覽器支援度還很差，需要更多時間，但大家應該有看過這張圖：</p>\n<img src=\"/image/appinstall.png\" alt=\"source: https://www.youtube.com/watch?v=MyQ8mtR9WxI\" style=\"width: 300px;\"/>\n<p>App 從下載到安裝使用的人數差了四分之一，如果 Progressive Web App 可以起來的話，相信對使用者與開發者來說都是雙贏的局面（更多人使用、又不會佔手機空間、又不用到 app store 更新），但大廠怎麼想就不知道了...</p>\n<p>但至少 Progressive web app 會帶給使用者更好的 web 瀏覽體驗是無庸置疑的！</p>\n<!-- 資料來源 -->\n<h2 id=\"資料來源\" style=\"position:relative;\"><a href=\"#%E8%B3%87%E6%96%99%E4%BE%86%E6%BA%90\" aria-label=\"資料來源 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>資料來源</h2>\n<ol>\n<li><a href=\"https://developers.google.com/web/fundamentals/getting-started/your-first-progressive-web-app/?hl=zh-tw\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Google developer web fundamentals</a></li>\n<li><a href=\"http://www.html5rocks.com/en/tutorials/service-worker/introduction/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">html5rocks: service-worker</a></li>\n<li><a href=\"https://developers.google.com/web/fundamentals/engage-and-retain/app-install-banners/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Google developer web app install banner</a></li>\n</ol>","id":"eeb84b85-b27f-55a1-9095-19d8c77d40c5","fields":{"slug":"progressive-web-app"},"frontmatter":{"date":"2016-07-18T20:46:02.000Z","title":"Progressive Web App 會是未來趨勢嗎？","tags":["pwa"],"type":"tech","slug":"progressive-web-app"},"timeToRead":16},"next":{"excerpt":"（最近的辦公室日常...）\n\"欸欸欸！ 有乾爹撒花！！\"\n\"有傑尼龜！\"\n\"Gotcha!! 偉哉乾爹！感恩乾爹！\"","html":"<blockquote>\n<p>（最近的辦公室日常...）\n\"欸欸欸！ 有乾爹撒花！！\"\n\"有傑尼龜！\"\n\"Gotcha!! 偉哉乾爹！感恩乾爹！\"</p>\n</blockquote>\n<!-- more -->\n<p>自從 Pokemon Go 在台灣可以玩後，勾起了我許多兒時回憶，因此除了跟著大家一起抓神奇寶貝以外（對我就是不想講寶可夢啊啊啊），我也稍微去追了一下最新版的神奇寶貝動畫，似乎是在打什麼卡洛斯聯盟，也出現了好奇怪的 Mega 進化，會讓神奇寶貝在戰鬥中轉屬性...</p>\n<p>咳咳，等等，再講下去這整篇都是神奇寶貝了...</p>\n<p>總之，看到會轉屬性這件事情就讓我想到，我小時候從來都沒有認真研究過哪種屬性剋哪種屬性，只知道基本的水剋火之類的，於是乎決定來好好研究一下，順便練習已經出來一陣子的 D3 v4，看看差異性在哪。</p>\n<p>幸運的是，當我在搜尋 Pokemon 的 API 時，發現 <a href=\"http://filipekiss.github.io/pokemon-type-chart/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">http://filipekiss.github.io/pokemon-type-chart/</a> 這個人已經把我想做的做完了 XD 也做得不錯。不過是兩三年前的專案，用的是 D3 v3。雖然點子已經被做完了，但臨摹也是一種學習，所以我們就來把它 Migrate 到 D3 v4，順便看看有哪些值得注意的地方吧！</p>\n<p>想直接看 code 的在這邊... <a href=\"http://bl.ocks.org/arvinh/b30ed888914a2794830ceb023c911a5b\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"><span style=\"color: #c40522;\">成果 與 程式碼</span></a></p>\n<h2 id=\"介紹\" style=\"position:relative;\"><a href=\"#%E4%BB%8B%E7%B4%B9\" aria-label=\"介紹 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>介紹</h2>\n<img src=\"/image/pokemontype.png\" alt=\"pokemon type\" style=\"width: 500px;\"/>\n<p>這張圖乍看之下我原本以為是修改自 Chord Diagram，但其實是來自於 Cluster。想想也對，屬性間的關係的確類似於階層樹狀，也不需要有比例分佈對應。\n( 從程式碼看來，原作者應該是修改自 <a href=\"https://bl.ocks.org/mbostock/7607999\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://bl.ocks.org/mbostock/7607999</a> )</p>\n<p>使用方法很簡單，只要點擊某個屬性，就會列出該屬性對哪些屬性較為強勢 (Strong)、弱勢 (Weak) 或是 免疫 (Immune)，同時點擊兩種屬性的話，就會秀出擁有雙重屬性的結果為何。</p>\n<h2 id=\"解析\" style=\"position:relative;\"><a href=\"#%E8%A7%A3%E6%9E%90\" aria-label=\"解析 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>解析</h2>\n<p>由於 D3 v4 的變動幅度很大，為了模組化，將很多 packages 都拆出來，替代以往使用 namespace 的方式，因此最單純的 Migration 方式就是直接重刻並設法 re-use 原來的 code。</p>\n<p>首先，基本的 <code class=\"language-text\">index.html</code> 內定義好圖要畫在哪裡，並加上一個 reset button 來還原圖表狀態：</p>\n<div class=\"gatsby-highlight\" data-language=\"html\"><pre class=\"language-html\"><code class=\"language-html\">  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span> <span class=\"token attr-name\">id</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>typeChart<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span> <span class=\"token attr-name\">id</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>graph<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>button</span> <span class=\"token attr-name\">class</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>button reset<span class=\"token punctuation\">\"</span></span><span class=\"token special-attr\"><span class=\"token attr-name\">onclick</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span><span class=\"token value javascript language-javascript\"><span class=\"token function\">reset</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></span><span class=\"token punctuation\">\"</span></span></span><span class=\"token punctuation\">></span></span>reset<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>button</span><span class=\"token punctuation\">></span></span></code></pre></div>\n<p>接著，我們需要先定義 <code class=\"language-text\">layout</code>，這邊使用 Cluster Layout，在原本的 D3 v3 版本中，使用的方式為：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsv3.js\"><pre class=\"language-jsv3.js\"><code class=\"language-jsv3.js\">  var diameter = 750,\n      radius = diameter / 2,\n      innerRadius = radius - 120;\n  var cluster = d3.layout.cluster()\n      .size([360, innerRadius])\n      .sort(null)\n      .value(function(d) { return d.size; });</code></pre></div>\n<p>然而，v4 模組化後，原本的 namespace 都不需要了，因為實際上是個別存放在一個 lib 底下，以 Layout 來說 會放在 <code class=\"language-text\">d3-hierarchy</code>，而使用方式則變成直接呼叫 <code class=\"language-text\">d3.cluster()</code> 即可，原有的 <code class=\"language-text\">sort()</code>, <code class=\"language-text\">value()</code>等 method 也都移到 <code class=\"language-text\">node</code> 這個層級底下了（後面會在講到 node）：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsv4.js\"><pre class=\"language-jsv4.js\"><code class=\"language-jsv4.js\">  // 定義圖形的基本設定值\n  var diameter = 750,\n      radius = diameter / 2,\n      innerRadius = radius - 120;\n\n  var cluster = d3.cluster()\n      .size([360, innerRadius]);</code></pre></div>\n<p>寫好圖形的基本設定值後，先把我們已知的 svg 放上去吧！\n我們先把剛剛定義好的 <code class=\"language-text\">diameter</code>, <code class=\"language-text\">radius</code> 的值 append 到最外層的 graph div 上，\n接著先把待會會用到的四種 svg group 先記錄起來，分別有 immune (免疫)、weak (弱勢)、strong (強勢)、node (屬性)</p>\n<div class=\"gatsby-highlight\" data-language=\"jsweaknesses-graph.js\"><pre class=\"language-jsweaknesses-graph.js\"><code class=\"language-jsweaknesses-graph.js\">var svg = d3.select(&quot;#typeChart &gt; #graph&quot;).append(&quot;svg&quot;)\n    .attr(&quot;width&quot;, diameter)\n    .attr(&quot;height&quot;, diameter)\n    .append(&quot;g&quot;)\n    .attr(&quot;transform&quot;, &quot;translate(&quot; + radius + &quot;,&quot; + radius + &quot;)&quot;);\n\nvar immune = svg.append(&quot;g&quot;).selectAll(&quot;.immune&quot;),\n    weak = svg.append(&quot;g&quot;).selectAll(&quot;.weak&quot;),\n    strong = svg.append(&quot;g&quot;).selectAll(&quot;.strong&quot;),\n    node = svg.append(&quot;g&quot;).selectAll(&quot;.node&quot;);</code></pre></div>\n<p>我蠻喜歡這樣的寫法，將與資料繪製較無關（相對較固定）的程式碼先寫好，接著再利用 <code class=\"language-text\">d3.json</code> 將資料讀入後去繪製。</p>\n<div class=\"gatsby-highlight\" data-language=\"jsdraw-graph\"><pre class=\"language-jsdraw-graph\"><code class=\"language-jsdraw-graph\">d3.json(&quot;types.json&quot;, function(error, classes) {\n    var nodes = cluster(d3.hierarchy(packageHierarchy(classes))).children;\n    var immunes = typeImmune(nodes);\n    var strengths = typeStrong(nodes);\n    var weaknesses = typeWeak(nodes);\n\n    // draw path\n\n    ......\n    ....\n    ..\n\n    //Make the immune links\n    function typeImmune(nodes) {\n    var map = {},\n        immunes = [];\n\n    nodes.forEach(function(d) {\n        map[d.data.name] = d;\n    });\n\n    nodes.forEach(function(d) {\n        if (d.data.immunes) d.data.immunes.forEach(function(i) {\n            immunes.push({\n                source: map[d.data.name],\n                target: map[i]\n            });\n        });\n    });\n\n        return immunes;\n    }\n    // 以下先省略\n});</code></pre></div>\n<p>解釋一下上面這段程式碼，我們的資料存放在 types.json 中，利用 d3.json 將資料讀出後，\n會先做兩件事情：</p>\n<ol>\n<li>將資料轉化成 hierarchy 格式，並初始化 cluster</li>\n<li>將產生的 nodes 轉化並分類成 immunes, strengths, weaknesses。</li>\n</ol>\n<p>這邊的 <code class=\"language-text\">packageHierarchy</code> 主要是將 raw data 整理成有父子關係的 structure，並且給予每筆資料自己的 <code class=\"language-text\">key</code> 與 <code class=\"language-text\">name</code>。（詳細程式碼可以到最後的連結看，這部分比較跟資料格式相關，就不放在這裡佔版面了）</p>\n<p>在原本 v3 的做法裡，如果我們要把資料轉化成 hierarchy 的格式，可以直接利用 <code class=\"language-text\">cluster.nodes()</code> ，即可一次初始化 cluster 並且得到擁有 x, y 值 的 nodes，但在 v4 中，我們必須先利用 <code class=\"language-text\">d3.hierarchy()</code> 將資料轉化成 hierarchy 格式，建立好父子關係與每個 node 的深度，接著才能丟入 <code class=\"language-text\">cluster</code> 中初始，其回傳值才會是擁有對應 cluster 內 x, y 值的 nodes。</p>\n<p><code class=\"language-text\">window.nodes = cluster(d3.hierarchy(packageHierarchy(classes))).children;</code>\n(這邊取 children 也只是資料格式的關係)</p>\n<p>由於繪製 <code class=\"language-text\">svg path</code> 需要給訂 data 的 source 與 target，因此這邊利用 <code class=\"language-text\">typeImmune</code>, <code class=\"language-text\">typeStrong</code>, <code class=\"language-text\">typeWeak</code> 來作轉換，也將資料分為這三種關係的 path 來繪製。</p>\n<p>接著，轉換好後就能根據 node 的 <code class=\"language-text\">source</code> 與 <code class=\"language-text\">target</code> 繪製 path。</p>\n<div class=\"gatsby-highlight\" data-language=\"jsdraw-path\"><pre class=\"language-jsdraw-path\"><code class=\"language-jsdraw-path\">// 這邊只列出一種\nwindow.immune = immune\n        .data(immunes.map(function(node){\n            return node.source.path(node.target);\n        }))\n        .enter().append(&quot;path&quot;)\n        .each(function(d) {\n            d.source = d[0], d.target = d[d.length - 1];\n        })\n        .attr(&quot;class&quot;, &quot;immune&quot;)\n        .attr(&quot;d&quot;, line);</code></pre></div>\n<p>以往在 v3，我們可以事先定義 <code class=\"language-text\">var bundle = d3.layout.bundle();</code>，然後在上面這段程式碼中的 <code class=\"language-text\">data()</code> 中呼叫 <code class=\"language-text\">bundle(immunes)</code>，他就會幫我們把 source 跟 target 做連接。</p>\n<p>但是在 v4 裡，<code class=\"language-text\">bundle</code> 被 <code class=\"language-text\">node.path()</code> 給取代了。</p>\n<p>注意喔！是 <code class=\"language-text\">node.path()</code>，層級是在 node，因此我們要從剛才分類好的 immunes 中將 node 一個一個抓出來呼叫。</p>\n<p>另外在這邊我們有用一個 <code class=\"language-text\">each()</code> 來將每筆 node 資料都加上 <code class=\"language-text\">d.source = d[0], d.target = d[d.length - 1];</code>\n原因是為了之後我們點擊每個類別的時候，要利用這個來找出對應的點來上色。</p>\n<div class=\"gatsby-highlight\" data-language=\"jscolorpath.js\"><pre class=\"language-jscolorpath.js\"><code class=\"language-jscolorpath.js\">window.colorPath = function(d, l, type) {\n      var type = type || &#39;strong&#39;;\n      if (type == &#39;strong&#39;) {\n        if (l.target === d) return l.source.target = true;\n      }\n      if (type == &#39;weak&#39;) {\n        for (type in d) {\n          if(type !== &quot;size&quot;) {\n            if (l.target === d[type]) return l.source.target = true;\n          }\n        }\n      }\n    }</code></pre></div>\n<p>到目前為止，已經把原本 v3 的 cluster layout 轉移到 v4 了，其餘繪製部分就與版本沒有什麼關聯性，需要注意的是資料格式的變動，像是在原本作者的程式碼內，點擊類別的 <code class=\"language-text\">activate()</code> 函數中，根據 <code class=\"language-text\">d.name</code> 來判斷位置的部分，由於資料格式的變動，要改為 <code class=\"language-text\">d.data.name</code>：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsactivate(d).js\"><pre class=\"language-jsactivate(d).js\"><code class=\"language-jsactivate(d).js\">    window.node\n        .classed(&quot;node--active&quot;, function(target) {\n            return (target === d) || this.classList.contains(&quot;node--active&quot;);\n        })\n        .classed(&quot;node--target&quot;, function(n) {\n            return n.target;\n        })\n        .classed(&quot;immune-node&quot;, function(target, l) {\n            return (this.classList.contains(&#39;immune-node&#39;) || target.data.immunes.indexOf(d.data.name) != -1);\n        })\n        ....\n        ...\n        ..</code></pre></div>\n<p>其餘繪製部分，包含點擊後的上色邏輯（ activate() 函數中），有興趣的讀者就直接看 code 吧，相信會更清楚！</p>\n<p><a href=\"http://bl.ocks.org/arvinh/b30ed888914a2794830ceb023c911a5b\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"><span style=\"font-size: 20px; color: #c40522;\">成果 與 程式碼</span></a></p>\n<p>不過實際上我並沒有完整 Migration 完成，在原本 v3 的 <code class=\"language-text\">d3.svg.line.radial()</code> 這裡，v4 的寫法應該是 <code class=\"language-text\">d3.radialLine()</code>，並搭配上 <code class=\"language-text\">curve()</code> 函數，只是我並沒有嘗試成功，還請高手指教！</p>\n<p>最後，送給大家一隻純 CSS 卡比獸，祝大家早日成為神奇寶貝大師！\n（好啦其實不像XD...畢竟我對 css 的掌控度大概跟我對腰間肥肉的掌控度一樣低落...）</p>\n<p data-height=\"448\" data-theme-id=\"dark\" data-slug-hash=\"dXLvVm\" data-default-tab=\"css,result\" data-user=\"arvin0731\" data-embed-version=\"2\" class=\"codepen\">See the Pen <a href=\"http://codepen.io/arvin0731/pen/dXLvVm/\">Snorlax-pokemon</a> by Arvin (<a href=\"http://codepen.io/arvin0731\">@arvin0731</a>) on <a href=\"http://codepen.io\">CodePen</a>.</p>\n<script async src=\"//assets.codepen.io/assets/embed/ei.js\"></script>","id":"473e535d-2e0b-55bb-8fa9-08d856ed9c3a","fields":{"slug":"d-3-pokemon"},"frontmatter":{"date":"2016-08-19T20:26:11.000Z","title":"用 D3.js v4 看 Pokemon 屬性表","tags":["d3","pokemon","d3v4","data visualization"],"type":"tech","slug":"d3-pokemon"},"timeToRead":7},"type":"tech"}},"staticQueryHashes":["2123680655"]}