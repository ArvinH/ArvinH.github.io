{"componentChunkName":"component---src-templates-post-tsx","path":"/tech/d-3-workshop-map","result":{"data":{"markdownRemark":{"html":"<blockquote>\n<p>~ $ What's the funny thing about UDP jokes?\n~ $ I don't care if you get them.</p>\n</blockquote>\n<!-- more -->\n<h2 id=\"前言\" style=\"position:relative;\"><a href=\"#%E5%89%8D%E8%A8%80\" aria-label=\"前言 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>前言</h2>\n<p>以前在做一些跟地圖有關的應用時，第一個出現在腦海的不外乎是 Google Map 和 OpenStreetMap，然後搭配 Leaflet 與 Mapbox 等工具來對 map tile 做各種加工渲染，然而到了工作上需要時就會發現這些工具在不付費、遵守授權的狀況下，就出現了各種限制，像是需要自己架設 tile server 來轉換 OpenStreetMap 的圖資，或是 request 的次數限制等等。</p>\n<p>想了想發現最好的替代方案就是直接用 svg 來繪製，雖然沒有辦法像 Google Map 那般詳細，但在某些應用上來說就非常足夠，效果也很好，因此今天就來紀錄一下該如何使用 D3.js 與 svg 來繪製出有動態路線功能的地圖，讓大家可以做出類似中央氣象局的颱風路線預覽圖的作品！</p>\n<p>先看一下成品：(P.S. 最近發現 <a href=\"https://codesandbox.io\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">codesandbox</a> 這個服務，比起在 jsbin 或是 jsfiddle 上寫 React 來說好用一些，缺點是 mobile 體驗較差)</p>\n<iframe src=\"https://codesandbox.io/embed/Wv9kBrJW?hidenavigation=1&view=preview\" style=\"width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;\" sandbox=\"allow-modals allow-forms allow-popups allow-scripts allow-same-origin\"></iframe>\n<h2 id=\"地圖資料搜集\" style=\"position:relative;\"><a href=\"#%E5%9C%B0%E5%9C%96%E8%B3%87%E6%96%99%E6%90%9C%E9%9B%86\" aria-label=\"地圖資料搜集 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>地圖資料搜集</h2>\n<p>要自己畫地圖，當然就必須自己準備好圖資，看你想要台灣地圖或是世界地圖，基本上在網路上都能找得到，但是在使用網路資料的時候都需要小心授權條款，以世界地圖為例，目前我看到最能自由運用的就是 <a href=\"http://www.naturalearthdata.com/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Natural Earth</a> 的資料了，基本上有分三種比例的圖資，1:10m、1:50m 與 1:100m:</p>\n<p><img src=\"/image/naturalearth.png\" alt=\"Natural Earth Dataset\"></p>\n<p>從 Natural Earth 載下來的會是 Vector data，無法直接使用在 D3.js 上，好在 D3.js 的作者 Mike Bostock 製作的另一套工具 <a href=\"ttps://github.com/topojson\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">topojson</a> 中已經有 parse 過後的 TopoJSON 檔案，可以直接透過 <code class=\"language-text\">https://unpkg.com/world-atlas@1/world/110m.json</code> 取得，<code class=\"language-text\">50m</code> 的也有，就換一下後面的檔名即可。</p>\n<p>如果你想要其他 Natural Earth 上的資料，其實也可以修改 <a href=\"https://github.com/topojson/world-atlas\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">world-atlas</a> 裡面的 script 來自己轉換成 TopoJSON，可以參考我 fork 過來修改的這份檔案 <a href=\"https://github.com/ArvinH/world-atlas/blob/master/prepublish-populor-place.sh\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">prepublish-populor-place.sh</a>，用來 parse Natural Earth 上的 popular_place data。</p>\n<h2 id=\"繪製基本的-svg-地圖\" style=\"position:relative;\"><a href=\"#%E7%B9%AA%E8%A3%BD%E5%9F%BA%E6%9C%AC%E7%9A%84-svg-%E5%9C%B0%E5%9C%96\" aria-label=\"繪製基本的 svg 地圖 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>繪製基本的 svg 地圖</h2>\n<p>已經有了資料來源，就可以開始動手將地圖繪製出來了！</p>\n<p>首先，React component 的起手式先準備好：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsworldmap.jsx\"><pre class=\"language-jsworldmap.jsx\"><code class=\"language-jsworldmap.jsx\">import React, { Component } from &#39;react&#39;;\nimport { render } from &#39;react-dom&#39;;\n\nclass WorldMap extends Component {\n  constructor() {\n    super()\n    this.state = {\n      worlddata: [],\n      typhoonPath: [],\n      marker: {},\n      graticule: geoGraticule10(),\n    }\n  }\n  \n  componentDidMount() {\n     fetch(&quot;https://unpkg.com/world-atlas@1/world/50m.json&quot;)\n      .then(response =&gt; {\n        if (response.status !== 200) {\n          console.log(`There was a problem: ${response.status}`)\n          return;\n        }\n        response.json().then(worlddata =&gt; {\n          this.setState({\n            worlddata: feature(worlddata, worlddata.objects.countries).features,\n          });\n        })\n      });\n  }\n\n  render() {\n    return (\n      &lt;svg className=&quot;map-svg&quot; width={ 800 } height={ 600 } viewBox=&quot;0 0 800 600&quot;&gt;\n      &lt;/svg&gt;\n    )\n  }\n}\n\nrender(&lt;WorldMap /&gt;, document.getElementById(&#39;root&#39;));</code></pre></div>\n<p>我在 <code class=\"language-text\">componentDidMount</code> 的時候去抓取地圖資料，接著才 <code class=\"language-text\">setState()</code>，但實際上你的專案可以先把資料存起來，這樣一來在 render 的地方就可以直接先 render 出 svg 地圖，這對於採用 Server-side rendering 的專案來說會方便很多，因為如果全部用 D3.js 的話，會需要先 select 到 DOM object 才能進行繪製，會麻煩一些。</p>\n<h3 id=\"利用-svg-path-繪製世界地圖\" style=\"position:relative;\"><a href=\"#%E5%88%A9%E7%94%A8-svg-path-%E7%B9%AA%E8%A3%BD%E4%B8%96%E7%95%8C%E5%9C%B0%E5%9C%96\" aria-label=\"利用 svg path 繪製世界地圖 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>利用 svg path 繪製世界地圖</h3>\n<p>在 svg 底下 append 一個 group，然後 iterate state 中的世界地圖資料，加上每個區塊的 svg path：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsworld_map_path.js\"><pre class=\"language-jsworld_map_path.js\"><code class=\"language-jsworld_map_path.js\">&lt;g className=&quot;countries&quot;&gt;\n    {\n    this.state.worlddata.map((d,i) =&gt; (\n        &lt;path\n        key={ `path-${ i }` }\n        d={ geoPath().projection(this.projection())(d) }\n        className=&quot;country&quot;\n        fill={ `rgba(219, 163, 43,${ 1 / this.state.worlddata.length * i})` }\n        stroke=&quot;#FFFFFF&quot;\n        strokeWidth={ 0.5 }\n        /&gt;\n    ))\n    }\n&lt;/g&gt;</code></pre></div>\n<p>這邊先看一下我們 state 中的 worlddata 到底是什麼東西：</p>\n<p><img src=\"/image/worldtopojson.png\" alt=\"World Map topojson\"></p>\n<p>這是一個 TopoJSON 的格式，TopoJSON 簡單來說可以當作效能更好的 GeoJSON，詳細介紹可以看 <a href=\"https://github.com/topojson/topojson\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">這裡</a>。Array 裡面的每一個 object 都是 type 為 Feature 的物件，其中的 geometry 包含了實際的地理資訊，可能是一個 Polygon，以及此 Polygon 每個點的座標。</p>\n<p>接著我們需要使用 <code class=\"language-text\">d3-geo</code> 中的 <code class=\"language-text\">geoPath</code>，其中有 <code class=\"language-text\">projection()</code> method 能讓我們把剛剛的座標投影（project）到我們繪製的地圖上。</p>\n<p>投影在地圖的繪製中扮演著極為重要的角色，透過投影，我們才能將真實世界的經緯度映射到我們網頁上小小的 svg 中。</p>\n<p><code class=\"language-text\">d3-geo</code> 中的 <code class=\"language-text\">geoPath.projection()</code> 會回傳一個 function，讓你傳地理資訊進去，接著回傳映射過後的 svg path，基本上就是一連串的 svg mini language，就是下列程式碼中的 <code class=\"language-text\">d</code> 的內容：</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token operator\">&lt;</span>path d<span class=\"token operator\">=</span>\"<span class=\"token constant\">M</span> <span class=\"token number\">10</span> <span class=\"token number\">25</span>\n         <span class=\"token constant\">L</span> <span class=\"token number\">10</span> <span class=\"token number\">75</span>\n         <span class=\"token constant\">L</span> <span class=\"token number\">60</span> <span class=\"token number\">75</span>\n         <span class=\"token constant\">L</span> <span class=\"token number\">10</span> <span class=\"token number\">25</span>\"</code></pre></div>\n<p>M 代表將 筆 移動到 (10, 25)，接著 L 畫一條線到 (10, 75)，以此類推。詳細介紹可看 <a href=\"https://www.dashingd3js.com/svg-paths-and-d3js\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">這裡</a>。</p>\n<p>當然，你必須傳入一個參數，告訴 <code class=\"language-text\">geoPath.projection()</code> 你想要映射的範圍為何，也就是 <code class=\"language-text\">world_map_path.js</code> 中 <code class=\"language-text\">#L6</code> 所傳入的 <code class=\"language-text\">this.projection()</code>：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsprojection\"><pre class=\"language-jsprojection\"><code class=\"language-jsprojection\">projection() {\n    return geoMercator()\n        .scale(1000)\n        .center([125.9605, 26.6978]);\n}</code></pre></div>\n<p>也是回傳一個 Function，利用到 <code class=\"language-text\">d3-geo</code> 的 <code class=\"language-text\">geoMercator</code>，可以定義好你要映射的 scale 是多大，中心位置在哪。</p>\n<p>最後為了讓每個國家的區塊有明顯區分，我們在 <code class=\"language-text\">fill</code> 的地方，隨機給他不同的顏色，<code class=\"language-text\">fill={ rgba(219, 163, 43,${ 1 / this.state.worlddata.length * i}) }</code></p>\n<p>到這個步驟你已經可以畫出下面這樣的地圖了：</p>\n<iframe src=\"https://codesandbox.io/embed/0RKnYZMAL?hidenavigation=1&view=preview\" style=\"width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;\" sandbox=\"allow-modals allow-forms allow-popups allow-scripts allow-same-origin\"></iframe>\n<h2 id=\"繪製動態路線---資料準備\" style=\"position:relative;\"><a href=\"#%E7%B9%AA%E8%A3%BD%E5%8B%95%E6%85%8B%E8%B7%AF%E7%B7%9A---%E8%B3%87%E6%96%99%E6%BA%96%E5%82%99\" aria-label=\"繪製動態路線   資料準備 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>繪製動態路線 - 資料準備</h2>\n<p>接著進行重頭戲，我們要在地圖上繪製出動態的路徑圖。</p>\n<p>第一個步驟也是先準備好資料，以文章開頭的成品來說，是我修改某年的颱風路徑資料而成的，如果想要串接目前的颱風路徑圖，可以到 <a href=\"http://opendata.cwb.gov.tw/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">氣象資料開放平臺</a> 申請會員，就可以拿到 API Key 去索取資料，格式會是 xml。</p>\n<p>API 範例：<code class=\"language-text\">http://opendata.cwb.gov.tw/opendataapi?dataid=W-C0034-004&amp;authorizationkey={你的 API key}</code>\n其中 <code class=\"language-text\">W-C0034-004</code> 是颱風路徑圖資料的 data id。</p>\n<p>資料中會有三個個主要部分，分別是過去的路徑資料 (past)、現在的位置 (curr) 與 未來預測的位置 (fcst)，簡單的 parser 可以參考我的 <a href=\"https://gist.github.com/ArvinH/66d1f9cedfc96deb956031502362202b\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">gist</a></p>\n<p>出來的結果格式如下，主要包含經緯度座標與颱風半徑：</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token punctuation\">{</span>\n    <span class=\"token string\">\"pastData\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span>\n        <span class=\"token punctuation\">{</span>\n            <span class=\"token string\">\"status\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"past\"</span><span class=\"token punctuation\">,</span>\n            <span class=\"token string\">\"time\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"2017-07-02T08:00:00+08:00\"</span><span class=\"token punctuation\">,</span>\n            <span class=\"token string\">\"coordinates\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span>\n                <span class=\"token number\">126.8</span><span class=\"token punctuation\">,</span>\n                <span class=\"token number\">20.9</span>\n            <span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n            <span class=\"token string\">\"radius\"</span><span class=\"token operator\">:</span> <span class=\"token number\">80</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n        <span class=\"token comment\">// ... 過往資料通常很多</span>\n    <span class=\"token punctuation\">]</span>\n    <span class=\"token string\">\"currData\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span>\n        <span class=\"token punctuation\">{</span>\n            <span class=\"token string\">\"status\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"curr\"</span><span class=\"token punctuation\">,</span>\n            <span class=\"token string\">\"time\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"2017-07-05T02:00:00+08:00\"</span><span class=\"token punctuation\">,</span>\n            <span class=\"token string\">\"coordinates\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span>\n                <span class=\"token number\">142.5</span><span class=\"token punctuation\">,</span>\n                <span class=\"token number\">35.1</span>\n            <span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n            <span class=\"token string\">\"radius\"</span><span class=\"token operator\">:</span> <span class=\"token number\">120</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n    <span class=\"token string\">\"fcstData\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span>\n        <span class=\"token punctuation\">{</span>\n            <span class=\"token string\">\"status\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"fcst\"</span><span class=\"token punctuation\">,</span>\n            <span class=\"token string\">\"time\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"2017-07-05T14:00:00+08:00\"</span><span class=\"token punctuation\">,</span>\n            <span class=\"token string\">\"coordinates\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span>\n                <span class=\"token number\">150.5</span><span class=\"token punctuation\">,</span>\n                <span class=\"token number\">36.7</span>\n            <span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n            <span class=\"token string\">\"radius\"</span><span class=\"token operator\">:</span> <span class=\"token number\">120</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2 id=\"繪製動態路線---路徑繪製\" style=\"position:relative;\"><a href=\"#%E7%B9%AA%E8%A3%BD%E5%8B%95%E6%85%8B%E8%B7%AF%E7%B7%9A---%E8%B7%AF%E5%BE%91%E7%B9%AA%E8%A3%BD\" aria-label=\"繪製動態路線   路徑繪製 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>繪製動態路線 - 路徑繪製</h2>\n<p>資料產生後，記得先放到 state 當中：</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"> <span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> pastData<span class=\"token punctuation\">,</span> currData<span class=\"token punctuation\">,</span> fcstData <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'./parsedWeatherData.json'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n <span class=\"token comment\">//...</span>\n <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>state <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n      worlddata<span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n      typhoonPath<span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token operator\">...</span>pastData<span class=\"token punctuation\">,</span> <span class=\"token operator\">...</span>currData<span class=\"token punctuation\">,</span> <span class=\"token operator\">...</span>fcstData<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n      marker<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span> name<span class=\"token operator\">:</span> <span class=\"token string\">\"201701\"</span><span class=\"token punctuation\">,</span> coordinates<span class=\"token operator\">:</span> pastData<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>coordinates <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span></code></pre></div>\n<p>順便加上一個 marker，用來代表颱風本體，以路徑圖的第一個位置為其座標起始點。</p>\n<p>接著我們另外寫一個 <code class=\"language-text\">renderLine()</code> function 來處理路徑繪製的部分，因為待會還會需要加上動畫效果，會複雜一些：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsrenderline\"><pre class=\"language-jsrenderline\"><code class=\"language-jsrenderline\">renderLine() {\n    // 座標映射\n    const pathCoordinates = [];\n    this.state.typhoonPath.forEach((path, i) =&gt; {\n      pathCoordinates.push({\n        x: this.projection()(path.coordinates)[0],\n        y: this.projection()(path.coordinates)[1]\n      });\n    });\n    \n    // 線段繪製函數\n    const lineFunction = d3Line()\n      .x((d) =&gt; d.x)\n      .y((d) =&gt; d.y)\n      .curve(curveCatmullRom);\n\n    // 增加 svg 元素\n    // add path\n    d3Select(&#39;svg&#39;)\n      .append(&#39;g&#39;)\n      .append(&#39;path&#39;)\n      .attr(&#39;class&#39;, &#39;typhoonPath&#39;)\n      .attr(&#39;d&#39;, lineFunction(pathCoordinates))\n      .attr(&#39;fill&#39;, &#39;none&#39;)\n      .attr(&#39;stroke&#39;, &#39;red&#39;)\n      .attr(&#39;stroke-width&#39;, &#39;5px&#39;);\n\n    // add marker\n    d3Select(&#39;svg&#39;)\n      .append(&#39;g&#39;)\n      .append(&#39;circle&#39;)\n        .attr(&quot;transform&quot;, () =&gt; {\n            const x = this.projection()(this.state.marker.coordinates)[0]\n            const y = this.projection()(this.state.marker.coordinates)[1]\n            return `translate(${x}, ${y})`;\n        })\n        .attr(&#39;r&#39;, 10)\n        .attr(&#39;fill&#39;, &#39;yellow&#39;)\n        .attr(&#39;opacity&#39;, 0.7)\n        .attr(&#39;class&#39;, &#39;typhoonMarker&#39;);\n\n    const linePath = d3SelectAll(&#39;path.typhoonPath&#39;);\n    \n  }</code></pre></div>\n<p>繪製路線的 <code class=\"language-text\">renderLine()</code> 可以拆成三部分來說明：</p>\n<ol>\n<li>座標映射：\n由於我們自己 parse 的路徑資料並非 TopoJSON，而且還區分成不同時間的資料，所以我們先個別將路徑映射好座標點，再串接到一個 Array 中，方便後續繪製。\n我們先前提到的 <code class=\"language-text\">projection()</code> 非常好用，只要傳入一個含有 x, y 經緯度的物件，就能幫我們在設定的 scale 中映射出對應位置：<code class=\"language-text\">this.projection()(path.coordinates)</code>，會回還一個 Array，分別為經度和緯度。</li>\n<li>線段繪製函數：\n在 D3.js 中，attribute 可以傳入 function，這邊我們利用 <code class=\"language-text\">d3-shape</code> 中的 <code class=\"language-text\">line</code>（ code 裡面的 d3Line 是我 import 後的變數名稱)來幫忙將映射後的座標 x, y 轉換成 svg path 的 d value。\n其中 <code class=\"language-text\">curve</code> 是 <code class=\"language-text\">d3-shape.line</code> 的補間函數，簡單來說就是決定線段中，每個 <strong>點</strong> 與 <strong>點</strong> 之間該怎麼 <strong>連接</strong>，看過這個對照應該會比較能了解：\n<a href=\"https://bl.ocks.org/d3noob/ced1b9b18bd8192d2c898884033b5529\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">v4 curve interpolation comparison</a>\n<img src=\"/image/linecurve-comparsion.png\" alt=\"curve interpolation comparison\"></li>\n<li>增加 svg 元素：\n這就是最基本的步驟囉，<code class=\"language-text\">d3-select</code> 出 svg 後，再 append 上我們要的 line path 與 marker，有寫過 D3.js 的勢必不陌生。</li>\n</ol>\n<p>在 <code class=\"language-text\">componentDidMount()</code> 的地方加上 <code class=\"language-text\">renderLine()</code> 函數，就可以看到如下結果：</p>\n<iframe src=\"https://codesandbox.io/embed/ERPYl4q94?hidenavigation=1&view=preview\" style=\"width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;\" sandbox=\"allow-modals allow-forms allow-popups allow-scripts allow-same-origin\"></iframe>\n<h2 id=\"繪製動態路線---加上動態路徑效果\" style=\"position:relative;\"><a href=\"#%E7%B9%AA%E8%A3%BD%E5%8B%95%E6%85%8B%E8%B7%AF%E7%B7%9A---%E5%8A%A0%E4%B8%8A%E5%8B%95%E6%85%8B%E8%B7%AF%E5%BE%91%E6%95%88%E6%9E%9C\" aria-label=\"繪製動態路線   加上動態路徑效果 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>繪製動態路線 - 加上動態路徑效果</h2>\n<p>接著我們要讓這個路徑 <strong>活起來</strong>！</p>\n<p>要讓 svg 線段有動畫般的效果其實很簡單，利用 svg 的 <code class=\"language-text\">stroke-dasharray</code> 這個屬性即可，詳細的實作原理可以看 css-tricks 上的這篇文章 <a href=\"https://css-tricks.com/svg-line-animation-works/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">How SVG Line Animation Works</a>，解釋的非常清楚，只是裡面說的做法是透過 CSS 的 animation，跟我們這邊有些微差異，但是原理是相同的。</p>\n<span style=\"color: red\">\n重點就在於，將原始的 **直線** 轉換為 **虛線**，透過改變該虛線的 **dasharray** 區間，來做出動態的效果。\n</span>\n<p>stroke-dasharray 的參數是 ( dash 的長度, gap 的長度 ))，我們只要固定 gap 的長度為線段長，然後讓 dash 的長度從零慢慢轉換成線段長即可達到動畫效果！</p>\n<p>所以我們加上一個 <code class=\"language-text\">transition</code> 函數：</p>\n<div class=\"gatsby-highlight\" data-language=\"jstransition\"><pre class=\"language-jstransition\"><code class=\"language-jstransition\">transition(linePath) {\n    const self = this;\n    linePath.transition()\n      .duration(15000)\n      .attrTween(&quot;stroke-dasharray&quot;, this.translateFn.bind(this, linePath))\n      .on(&#39;end&#39;, () =&gt; {\n        setTimeout(() =&gt; {\n           d3Select(this).call(self.transition.bind(self, linePath)); // infinite loop\n        }, 1500);\n      });\n}</code></pre></div>\n<p><code class=\"language-text\">linePath</code> 是 <code class=\"language-text\">d3-select</code> 到的路徑 path 元件。透過 <code class=\"language-text\">transition()</code> 與 <code class=\"language-text\">attrTween()</code> 來動態調整 <code class=\"language-text\">stroke-dasharray</code> 的值，並且在最後監聽一個 <code class=\"language-text\">end</code> 事件，也就是當每次動畫結束以後，我們隔個 1.5 秒再重新呼叫一次 <code class=\"language-text\">transition()</code>，進行 loop。</p>\n<p><strong>[Note]</strong>\n這邊要注意的是，<code class=\"language-text\">linePath</code> 雖然是透過 <code class=\"language-text\">d3-select</code> 取得的元件，要呼叫他的 <code class=\"language-text\">transition()</code> 函式的話，會需要額外加入 <code class=\"language-text\">d3-transition</code> 的 lib 才行，他會將 <code class=\"language-text\">transition</code> bind 到元件中：\n<code class=\"language-text\">import { transition as d3Transition } from 'd3-transition';</code></p>\n<p><code class=\"language-text\">attrTween</code> 會將 <code class=\"language-text\">transition</code> 過程中的<strong>時間</strong>當作參數丟進去給它的 <strong>value</strong>，而該 <strong>value</strong> 扮演著處理 <strong>補間動畫</strong> 的角色，是一個 input 為時間的補間函式，我們這邊執行一個<code class=\"language-text\">translateFn()</code>，用來處理我們補間動畫過程中需要做的事情，以及定義補間動畫函式的內容：</p>\n<div class=\"gatsby-highlight\" data-language=\"jstranslatefn\"><pre class=\"language-jstranslatefn\"><code class=\"language-jstranslatefn\">translateFn(linePath) {\n    const self = this;\n    // 回傳 input 為 time 的補間函式\n    return (t) =&gt; {\n        const l = linePath.node().getTotalLength();\n        const p = linePath.node().getPointAtLength(t * l);\n        const marker = d3Select(&#39;.typhoonMarker&#39;);\n        marker.attr(&quot;transform&quot;, `translate(${p.x}, ${p.y})`);\n        marker.style(&quot;transition&quot;, &#39;r 1.5s&#39;);\n        marker.attr(&quot;r&quot;, 10);\n        const interpolate = d3Interpolate(`0,${l}`, `${l},${l}`);\n\n        return interpolate(t);\n    }\n}</code></pre></div>\n<p>如同先前提到的，我們要改變 <code class=\"language-text\">stroke-dasharray</code> 的區間，也就是要讓第一個參數，dash 的長度遞增為線段長，線段長度可以從 <code class=\"language-text\">linePath.node().getTotalLength()</code> 取得，透過 <code class=\"language-text\">d3-interpolate</code> 幫助我們產生一個補間函式 <code class=\"language-text\">interpolate(t)</code>，補完 <code class=\"language-text\">0, 線段長</code> -> <code class=\"language-text\">線段長, 線段長</code> 這段參數的變化，並且回傳出去給 <code class=\"language-text\">attrTween</code>。</p>\n<p><code class=\"language-text\">d3</code> 的文件都顯得蠻詳細的，<a href=\"https://github.com/d3/d3-interpolate#interpolate\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">d3-interpolate</a> 這邊有說明不同的 input type 會採用不同的補間函式來處理，例如字串、時間、數字等等。</p>\n<p>加上了這個 <code class=\"language-text\">tranlsateFn</code> 後，線段就活起來了！</p>\n<iframe src=\"https://codesandbox.io/embed/Q1KBD2WLZ?hidenavigation=1&view=preview\" style=\"width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;\" sandbox=\"allow-modals allow-forms allow-popups allow-scripts allow-same-origin\"></iframe>\n<p>在剛剛的 <code class=\"language-text\">translateFn</code> 中我們其實還做了一件事情，就是讓 Marker 跟著線段移動，透過 <code class=\"language-text\">const p = linePath.node().getPointAtLength(t * l);</code> 取得線段在該時間的 point 位置，並 transform 過去。</p>\n<p>但這樣還不夠，既然是想要有颱風路徑的效果，怎麼可以缺少了暴風半徑的資訊呢？</p>\n<p>記得我們原本 parse 出來的資料中有個 <code class=\"language-text\">radius</code> 的值嗎？我們可以在 <code class=\"language-text\">translateFn</code> 中抓出目前資料的半徑值，然後放到 marker 的 <code class=\"language-text\">r</code> attribute 中：</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\">self<span class=\"token punctuation\">.</span>state<span class=\"token punctuation\">.</span>typhoonPath<span class=\"token punctuation\">.</span><span class=\"token function\">forEach</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">path</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">const</span> pixelLocSource <span class=\"token operator\">=</span> self<span class=\"token punctuation\">.</span><span class=\"token function\">projection</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>path<span class=\"token punctuation\">.</span>coordinates<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>Math<span class=\"token punctuation\">.</span><span class=\"token function\">floor</span><span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">.</span>x<span class=\"token punctuation\">)</span> <span class=\"token operator\">===</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">floor</span><span class=\"token punctuation\">(</span>pixelLocSource<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token keyword\">const</span> radius <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">distanceCalculate</span><span class=\"token punctuation\">(</span>pixelLocSource<span class=\"token punctuation\">,</span> path<span class=\"token punctuation\">.</span>coordinates<span class=\"token punctuation\">,</span> path<span class=\"token punctuation\">.</span>radius<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n          marker<span class=\"token punctuation\">.</span><span class=\"token function\">attr</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"r\"</span><span class=\"token punctuation\">,</span> radius<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>但這邊還有個小問題，資料中，半徑的單位是 km，我要怎麼讓它轉換成 svg 中的距離呢？！我們之前的投影函式 <code class=\"language-text\">projection()</code> 只能接受座標參數，沒辦法直接轉換距離啊！</p>\n<p>別慌張，那我們就先計算出中心點到這段半徑後的座標，在轉換成地圖上的點，接著利用國高中數學計算出距離即可！</p>\n<div class=\"gatsby-highlight\" data-language=\"jsdistancecalculate\"><pre class=\"language-jsdistancecalculate\"><code class=\"language-jsdistancecalculate\">distanceCalculate(pixelLocSource, [longitude, latitude], distance){\t\n    // Latitude: 1 deg = 110.574 km\n    // Longitude: 1 deg = 111.320*cos(latitude) km\n    const lat_diff = distance / 110.574;\n    const lon_distance = 111.320 * Math.cos(latitude * Math.PI / 180);\n    const lon_diff = distance / lon_distance;\n  \n    const E = longitude + Math.abs(lon_diff);\n    const pixelLoc = this.projection()([E, latitude]);\n    // distance calculate\n    return Math.sqrt(Math.pow(pixelLocSource[0] - pixelLoc[0], 2) + Math.pow(pixelLocSource[1] - pixelLoc[1], 2));\n}</code></pre></div>\n<p>取巧的點是，利用已知的經緯度距離來做運算：\nLatitude: 1 deg = 110.574 km\nLongitude: 1 deg = 111.320*cos(latitude) km</p>\n<p><code class=\"language-text\">pixelLocSource</code> 是映射過後的中心點位置，<code class=\"language-text\">[longitude, latitude]</code> 則是中心點的原始經緯度，而 <code class=\"language-text\">distance</code> 就是我們要算的暴風半徑。\n由於我們並不需要算出真正半徑內每個點的經緯度，所以這邊我只抓該緯度上的精度來做投影計算，找出該半徑後的精度，再套用普通的兩點距離公式。</p>\n<p>（其實這是我想出來比較暴力的解法啦，歡迎知道有更簡單更好的方式映射距離的朋友告知我！非常感謝）</p>\n<p>最後的成果（將 scale 調大比較看得出來半徑變化）：</p>\n<iframe src=\"https://codesandbox.io/embed/Xo0gjl6qA?hidenavigation=1&view=preview\" style=\"width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;\" sandbox=\"allow-modals allow-forms allow-popups allow-scripts allow-same-origin\"></iframe>\n<p>結論：</p>\n<p>要讓路徑在地圖上動起來並不困難，而且透過 D3.js 的補間函式也能讓你在補間過程中偷做許多手腳，像是我最一開始的範例中還有多判斷資料的時間，針對不同時間留下颱風半徑範圍圖等等。\n本篇的重點在於如何單純透過 D3.js v4 與 svg 的操作來製作出地圖上的動態線段，其他像是基本的經緯度線段 (graticule) 礙於篇幅關係就不細談，相信大家可以從我最一開始的範例中看出是如何製作的。希望本文能對想用 svg 繪製動態路線圖的讀者有所幫助，若文中有任何錯誤也歡迎指正！</p>\n<h2 id=\"資料來源\" style=\"position:relative;\"><a href=\"#%E8%B3%87%E6%96%99%E4%BE%86%E6%BA%90\" aria-label=\"資料來源 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>資料來源</h2>\n<ol>\n<li><a href=\"http://www.naturalearthdata.com/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Natural Earth</a></li>\n<li><a href=\"ttps://github.com/topojson\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">topojson</a></li>\n<li><a href=\"https://css-tricks.com/svg-line-animation-works/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">How SVG Line Animation Works</a></li>\n<li><a href=\"https://www.dashingd3js.com/svg-paths-and-d3js\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">SVG Paths and D3.js</a></li>\n<li><a href=\"http://andyshora.com/tweening-shapes-paths-d3-js.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">TWEENING CUSTOM SHAPES AND PATHS IN D3.JS</a></li>\n<li><a href=\"http://www.oxxostudio.tw/articles/201411/svg-d3-02-line.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">SVG D3.js - 繪製線段</a></li>\n<li><a href=\"https://bl.ocks.org/dimitardanailov/6f0a451d4457b9fa7bf6e0dddcd0f468\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">D3.js Path Data Generator Line Example</a></li>\n<li><a href=\"https://bl.ocks.org/d3noob/ced1b9b18bd8192d2c898884033b5529\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">v4 curve interpolation comparison</a></li>\n</ol>","fields":{"slug":"d-3-workshop-map"},"frontmatter":{"title":"D3v4 工作坊 - React + D3 繪製 svg 動態路線地圖","date":"07-21-2017","tags":["d3","react","svg","d3v4","data visualization"]},"timeToRead":14}},"pageContext":{"slug":"d-3-workshop-map","prev":{"excerpt":"~ $ man woman\n~ $ man: No manual entry for woman","html":"<blockquote>\n<p>~ $ man woman\n~ $ man: No manual entry for woman</p>\n</blockquote>\n<!-- more -->\n<h2 id=\"前言\" style=\"position:relative;\"><a href=\"#%E5%89%8D%E8%A8%80\" aria-label=\"前言 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>前言</h2>\n<p>時間過得很快，記得第一次聽到 WebAssembly 這個名詞是在 2015 年，小弟還在服役...當時看到的文章以聳動的標題訴說著 JavaScript 即將要被取代，各家大廠紛紛投入開發...（我就不轉貼這種文章了）害我想說是不是退役後會找不到工作...</p>\n<p>還好事實總是背離記者，WebAssembly 當然不是來取代 JavaScript 的，可以看看 <a href=\"https://brendaneich.com/2015/06/from-asm-js-to-webassembly/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">JavaScript 的發明人 Brendan Eich 怎麼說</a> 以及 <a href=\"https://www.youtube.com/watch?time_continue=1108&#x26;v=aZqhRICne_M\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">他在 Fluent conference 的 keynote</a>。</p>\n<p>但即便知道 WebAssembly 並非要取代 JavaScript，我其實也還是一直搞不太懂身為開發者，到底要如何使用 WebAssembly，只知道它似乎讓 C/C++ 跑在 Browser 上這件事變成可行，也能大幅提升 JavaScript 的效能。</p>\n<p>直到前陣子發現一部限時免費的教學影片 - <a href=\"https://egghead.io/courses/get-started-using-webassembly-wasm\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Get Started Using WebAssembly (wasm)</a>，我才稍稍領悟了一些。這部由 <a href=\"https://egghead.io/instructors/guy-bedford\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Guy Bedford</a> 製作的影片在 egghead.io 上，短短 56 分鐘，以實際範例告訴你如何使用 WebAssembly，以及與 JS 進行效能比較，也介紹了許多方便你測試的工具，有時間的話我強烈推薦把它看完，不過現在已經要是 egghead 的 pro member 才能看得到了... (作者有 open source 他所有的範例 code 在 <a href=\"https://github.com/guybedford/wasm-intro\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">guybedford/wasm-intro</a> 與 <a href=\"https://github.com/guybedford/wasm-demo\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">guybedford/wasm-demo</a>)</p>\n<p>可能你沒有時間也沒有多餘的錢能付費觀看，但沒關係，希望憑著我的記憶，透過這篇文章融合一些影片的重點，讓大家快速了解 WebAssembly 是什麼，以及要如何與 JavaScript 搭配使用。</p>\n<h2 id=\"什麼是-webassembly-wasm\" style=\"position:relative;\"><a href=\"#%E4%BB%80%E9%BA%BC%E6%98%AF-webassembly-wasm\" aria-label=\"什麼是 webassembly wasm permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>什麼是 WebAssembly (wasm)？</h2>\n<blockquote>\n<p>WebAssembly or wasm is a new, portable, size- and load-time-efficient format suitable for compilation to the web. -- <a href=\"https://github.com/WebAssembly/design\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">WebAssembly Design</a></p>\n</blockquote>\n<ol>\n<li>一種二進位表示的新語言，但有另外的 text format 可以讓你編輯與 debug。</li>\n<li>Compile Target：顧名思義，只要透過特定的 Compiler，你就能將你自己慣用的語言編譯成 WebAssembly，然後執行在瀏覽器上！目前可以透過 <a href=\"http://kripken.github.io/emscripten-site/index.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Emscripten(LLVM to JS compiler)</a> 來編譯 C/C++ 的程式。</li>\n<li>提供增強 JavaScript 程式的方法：你可以將 performance critical 的程式部分用 WebAssembly 撰寫，或是用第 2 點提及的 C/C++編譯成 WebAssembly，然後像一般 import js module 一般，導入你的 JavaScript Application。透過 WebAssembly，你能夠自由控制 Memory 的存取與釋放。</li>\n<li>當 Browser 能夠支援運行 WebAssembly 的時候，由於二進位格式以及事先編譯與優化的關係，勢必能夠產生比 JavaScript 運行速度更快、檔案大小更小的結果。</li>\n<li>語言的安全性 WebAssembly 當然也很重視，在 JavaScript VM 中， WebAssembly 運行在一個沙箱化的執行環境，遷入 web 端運行時會強制使用 Browser 的 Same-Origin 和 permissions security policies。此外，wasm 的實作設計中更特別提及他是 <a href=\"https://github.com/WebAssembly/design/blob/master/Security.md#memory-safety\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">memory-safe</a> 的。</li>\n<li><a href=\"https://github.com/WebAssembly/design/blob/master/NonWeb.md\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Non-Web Embeddings</a>：雖然是為了 Web 設計，但也希望能在其他環境中運行，因此底層實作並沒有 require Web API，讓其擁有良好的 portability，不管是 Nodejs, IoT devices 都可使用。</li>\n</ol>\n<p>WebAssembly 目前由 <a href=\"https://www.w3.org/community/webassembly/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">W3C Community Group</a> 設計開發，成員包含所有 major browsers 的代表。</p>\n<p>WebAssembly 有許多 <a href=\"http://webassembly.org/docs/high-level-goals/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">High-Level Goals</a>，目前 release 的版本主要為 <a href=\"http://webassembly.org/docs/mvp/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">MVP(Minimum Viable Product)</a>，提供先前 <code class=\"language-text\">asm.js</code> 的多數功能，並先以 C/C++ 的編譯為主。</p>\n<h2 id=\"等等第一點就有問題了你說他是二進位表示的語言那該怎麼寫text-format-又是長什麼樣子\" style=\"position:relative;\"><a href=\"#%E7%AD%89%E7%AD%89%E7%AC%AC%E4%B8%80%E9%BB%9E%E5%B0%B1%E6%9C%89%E5%95%8F%E9%A1%8C%E4%BA%86%E4%BD%A0%E8%AA%AA%E4%BB%96%E6%98%AF%E4%BA%8C%E9%80%B2%E4%BD%8D%E8%A1%A8%E7%A4%BA%E7%9A%84%E8%AA%9E%E8%A8%80%E9%82%A3%E8%A9%B2%E6%80%8E%E9%BA%BC%E5%AF%ABtext-format-%E5%8F%88%E6%98%AF%E9%95%B7%E4%BB%80%E9%BA%BC%E6%A8%A3%E5%AD%90\" aria-label=\"等等第一點就有問題了你說他是二進位表示的語言那該怎麼寫text format 又是長什麼樣子 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>等等，第一點就有問題了，你說他是二進位表示的語言，那該怎麼寫？！text format 又是長什麼樣子？</h2>\n<p>問得好，這就是本篇的重點，WebAssembly 的檔案格式為 <code class=\"language-text\">wasm</code>，舉一個例子來看，一個用 c++ 撰寫的加法函數：</p>\n<div class=\"gatsby-highlight\" data-language=\"cadd.c\"><pre class=\"language-cadd.c\"><code class=\"language-cadd.c\">#include &lt;math.h&gt;\nint add(int num1, int num2) {\n    return num1 + num2;\n}</code></pre></div>\n<p>若編譯為 <code class=\"language-text\">wasm</code> 會長這個樣子（為節省空間我轉成 Hex）：</p>\n<div class=\"gatsby-highlight\" data-language=\"wasmadd.wasm\"><pre class=\"language-wasmadd.wasm\"><code class=\"language-wasmadd.wasm\">00 61 73 6d 01 00 00 00  01 87 80 80 80 00 01 60\n02 7f 7f 01 7f 03 82 80  80 80 00 01 00 04 84 80\n80 80 00 01 70 00 00 05  83 80 80 80 00 01 00 01\n06 81 80 80 80 00 00 07  95 80 80 80 00 02 06 6d\n65 6d 6f 72 79 02 00 08  5f 5a 33 61 64 64 69 69\n00 00 0a 8d 80 80 80 00  01 87 80 80 80 00 00 20\n01 20 00 6a 0b</code></pre></div>\n<p>當然我們很難去編輯這樣的東西，所以有另一種 <strong>text format</strong> 叫做 <code class=\"language-text\">wast</code>，上述的 .wasm 轉成 .wast 後：</p>\n<div class=\"gatsby-highlight\" data-language=\"wastadd.wast\"><pre class=\"language-wastadd.wast\"><code class=\"language-wastadd.wast\">(module\n  (table 0 anyfunc)\n  (memory $0 1)\n  (export &quot;memory&quot; (memory $0))\n  (export &quot;add&quot; (func $add))\n  (func $add (param $0 i32) (param $1 i32) (result i32)\n    (i32.add\n      (get_local $1)\n      (get_local $0)\n    )\n  )\n)</code></pre></div>\n<p>這樣就好懂多了，我們一行一行來解釋：</p>\n<p><code class=\"language-text\">line 1</code> 的 module 就是 WebAssembly 中一個可載入、可執行的最小單位程式，在 runtime 載入後可以產生 Instance 來執行，而這個 module 也朝著與 ES6 modules 整合的方向，也就是說以後能透過 <code class=\"language-text\">&lt;script src=\"abc.wasm\" type=\"module\" /></code> 的方式載入。</p>\n<p><code class=\"language-text\">line 2 ~ 3</code> 分別宣告了兩個預設的環境變量: <code class=\"language-text\">memory</code> 與 <code class=\"language-text\">table</code>，memory 就是存放變數的記憶體物件，而 table 則是 WebAssembly 用來存放 function reference 的地方，在目前 MVP 的版本中，table 的 element type 只能為 <code class=\"language-text\">anyfunc</code>。</p>\n<p>接著 <code class=\"language-text\">line 4 ~ 5</code> 把 memory 與 add function export 出去。之後在 JavaScript 中，我們可以取得這兩個被 export 出來的物件與函式。</p>\n<p>最後是加法函式的宣告與實作內容，其中 <code class=\"language-text\">get_local</code> 是 WebAssembly 中取得 memory 中 local 變數的方法。</p>\n<p>不知道會不會有人好奇 i32 是什麼？i32 指的就是 32位元的整數，在 WebAssembly 的世界中，是強型態的，必須明確指定變數型態，寫習慣 JS 的要多加注意，稍後的範例會再度提及。</p>\n<!-- ## 工具包 -->\n<h2 id=\"那到底怎麼將-cc-編譯成-wasm-或-wast-呢\" style=\"position:relative;\"><a href=\"#%E9%82%A3%E5%88%B0%E5%BA%95%E6%80%8E%E9%BA%BC%E5%B0%87-cc-%E7%B7%A8%E8%AD%AF%E6%88%90-wasm-%E6%88%96-wast-%E5%91%A2\" aria-label=\"那到底怎麼將 cc 編譯成 wasm 或 wast 呢 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>那到底怎麼將 C/C++ 編譯成 wasm 或 wast 呢？</h2>\n<p><a href=\"http://webassembly.org/getting-started/developers-guide/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">WebAssembly.org</a> 中介紹我們使用 <a href=\"https://github.com/kripken/emscripten\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Emscripten</a>，Emscripten 的安裝與使用方法大家可以從官網上看到，就不贅述。</p>\n<p>安裝好後執行 <code class=\"language-text\">emcc add.c -s WASM=1 -o add.html</code> 即可，唯一要注意的是 <code class=\"language-text\">WASM=1</code> 這個 flag 要設定，否則 <code class=\"language-text\">emcc</code> 預設會跑 asm.js。</p>\n<p>如果只是想嚐鮮一下，可能看到要安裝這些東西就會把網頁關掉了...</p>\n<p>不過不用擔心！現在也已經有很方便的 online tool 可以使用：</p>\n<p><a href=\"https://wasdk.github.io/WasmFiddle\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">WasmFiddle</a></p>\n<p><img src=\"/image/wasmFiddle.png\" alt=\"WasmFiddle\"></p>\n<!-- Fiddle 的限制 -->\n<p>WasmFiddle 可以幫你把 C code 轉成 Wast 與 Wasm (可下載)，然後同時讓你直接利用 JS 進行操作，缺點是沒辦法直接更改 Wast。</p>\n<p><a href=\"http://mbebenita.github.io/WasmExplorer/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">WasmExplorer</a>：</p>\n<p><img src=\"/image/wasmExplorer.png\" alt=\"wasmExplorer\"></p>\n<!-- Explorer 的限制 -->\n<p>WasmExplorer 一樣能幫你把 C code 編譯成 Wast 與 Wasm，並且可以編輯轉出來的 Wast，缺點是沒有 JS 能直接互動。</p>\n<h3 id=\"所以搭配操作的流程\" style=\"position:relative;\"><a href=\"#%E6%89%80%E4%BB%A5%E6%90%AD%E9%85%8D%E6%93%8D%E4%BD%9C%E7%9A%84%E6%B5%81%E7%A8%8B\" aria-label=\"所以搭配操作的流程 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>所以搭配操作的流程...</h3>\n<blockquote>\n<p>先 WasmFiddle 來進行測試，接著把編好的 Wast 複製到 WasmExplorer 進行你想要的編輯，接著再 compile 成 wasm 並下載下來。</p>\n</blockquote>\n<!-- ## 與 JS 的交互使用-->\n<h2 id=\"知道怎麼編譯-wasm-後該說說-javascript-了吧\" style=\"position:relative;\"><a href=\"#%E7%9F%A5%E9%81%93%E6%80%8E%E9%BA%BC%E7%B7%A8%E8%AD%AF-wasm-%E5%BE%8C%E8%A9%B2%E8%AA%AA%E8%AA%AA-javascript-%E4%BA%86%E5%90%A7\" aria-label=\"知道怎麼編譯 wasm 後該說說 javascript 了吧 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>知道怎麼編譯 wasm 後，該說說 JavaScript 了吧</h2>\n<p>好的，但在那之前，要先提醒大家，除了 Chrome 57, Firefox 52 預設支援 WebAssembly 外，Safari 需要是紫色版本（Preview 版）才能使用，而 Edge 15 則是要開啟 Experimental JavaScript Features。</p>\n<h3 id=\"載入-wasm-到-web-端\" style=\"position:relative;\"><a href=\"#%E8%BC%89%E5%85%A5-wasm-%E5%88%B0-web-%E7%AB%AF\" aria-label=\"載入 wasm 到 web 端 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>載入 wasm 到 Web 端</h3>\n<p>在 <code class=\"language-text\">&lt;script src=\"abc.wasm\" type=\"module\" /></code> 還無法使用之前，想要載入 wasm 必須透過 <code class=\"language-text\">fetch</code> API。在 <a href=\"https://github.com/guybedford/wasm-intro/blob/master/4-reading-wasm-memory/test.html#L4\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Guy bedford 的影片範例</a> 與 <a href=\"https://github.com/mdn/webassembly-examples/blob/master/wasm-utils.js#L6\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">mdn 的 example</a> 中的寫法都差不多：</p>\n<div class=\"gatsby-highlight\" data-language=\"jswasm-loader.js\"><pre class=\"language-jswasm-loader.js\"><code class=\"language-jswasm-loader.js\">function fetchAndInstantiateWasm (url, imports) {\n    return fetch(url) // url could be your .wasm file\n    .then(res =&gt; {\n    if (res.ok)\n        return res.arrayBuffer();\n    throw new Error(`Unable to fetch Web Assembly file ${url}.`);\n    })\n    .then(bytes =&gt; WebAssembly.compile(bytes))\n    .then(module =&gt; WebAssembly.instantiate(module, imports || {}))\n    .then(instance =&gt; instance.exports);\n}</code></pre></div>\n<p>基本上會實作一個 <code class=\"language-text\">wasm-loader</code> 之類的函式，像上面的 <code class=\"language-text\">fetchAndInstantiateWasm</code>。</p>\n<p>內容很簡單，取得 fetch 回來的 result 後，將其轉為 <code class=\"language-text\">ArrayBuffer</code>，利用 <code class=\"language-text\">WebAssembly.compile</code> 這個 Web API 來產生 WebAssembly Module，接著透過 <code class=\"language-text\">WebAssembly.instantiate</code> 來產生 module instance，最後的 instance.exports 就是我們在 wasm 中 export 出來的物件或 function。</p>\n<p>除了 <code class=\"language-text\">fetch</code> 以外，<code class=\"language-text\">WebAssembly.compile</code> 與 <code class=\"language-text\">WebAssembly.instantiate</code> 也都是回傳 Promise。</p>\n<p>這邊出現一個相信一般前端開發者也比較少看到的 <strong>ArrayBuffer</strong>。</p>\n<p>ArrayBuffer 是 JavaScript 的一種 data type，用來表示 generic, fixed-length 的 binary data buffer，屬於 <strong>typed arrays</strong> 的一部分，而關於 <strong>typed arrays</strong> 雖然在 WebAssembly 中很重要，但是難以在這邊詳述，<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Typed_arrays\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">mdn 的文件</a>寫得很清楚，值得閱讀。</p>\n<p>我們目前只要知道他是一個 array-like 的物件，讓我們能在 JavaScript 中存取 raw binary data，有 <code class=\"language-text\">Int8Array</code>、<code class=\"language-text\">Int32Array</code> 與 <code class=\"language-text\">Float32Array</code> 等 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">DataView</a> 可以使用即可。（又一個名詞...DataView 提供 getter/setter API 來對 buffer 中的 data 做讀取。）</p>\n<p>回到主題，如果你剛剛有先點進 <a href=\"https://github.com/mdn/webassembly-examples/blob/master/wasm-utils.js#L6\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">mdn 的 example</a> 看，可能會發現他怎麼沒有 <code class=\"language-text\">WebAssembly.compile</code> 這個步驟？</p>\n<p>實際上 <code class=\"language-text\">WebAssembly.instantiate</code> 有兩種 overload 實作：</p>\n<ul>\n<li><code class=\"language-text\">Promise&lt;ResultObject> WebAssembly.instantiate(bufferSource, importObject);</code></li>\n<li><code class=\"language-text\">Promise&lt;WebAssembly.Instance> WebAssembly.instantiate(module, importObject);</code></li>\n</ul>\n<p>差別在於，先透過 <code class=\"language-text\">WebAssembly.compile</code> 後產生的 WebAssembly module，可以存在 indexedDB 中 cache，或是在 web workers 之間傳遞。</p>\n<p>此外，WebAssembly.Instance 的第二個參數：<code class=\"language-text\">importObject</code> 是用來傳遞 JavaScript 的參數或 function 到 WebAssembly 程式中使用，後面會有範例。 </p>\n<h2 id=\"在-javascript-中使用-webassembly-實作的-function\" style=\"position:relative;\"><a href=\"#%E5%9C%A8-javascript-%E4%B8%AD%E4%BD%BF%E7%94%A8-webassembly-%E5%AF%A6%E4%BD%9C%E7%9A%84-function\" aria-label=\"在 javascript 中使用 webassembly 實作的 function permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>在 JavaScript 中使用 WebAssembly 實作的 function</h2>\n<p>有了剛剛的 <code class=\"language-text\">fetchAndInstantiateWasm</code>，取得 WebAssembly function 很方便：</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token function\">fetchAndInstantiateWasm</span><span class=\"token punctuation\">(</span><span class=\"token string\">'add.wasm'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">m</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n      console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>m<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token number\">5</span><span class=\"token punctuation\">,</span> <span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 15</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>使用上就是這麼簡單！</p>\n<h2 id=\"那能不能在-webassembly-中使用-javascript-寫的-function-呢\" style=\"position:relative;\"><a href=\"#%E9%82%A3%E8%83%BD%E4%B8%8D%E8%83%BD%E5%9C%A8-webassembly-%E4%B8%AD%E4%BD%BF%E7%94%A8-javascript-%E5%AF%AB%E7%9A%84-function-%E5%91%A2\" aria-label=\"那能不能在 webassembly 中使用 javascript 寫的 function 呢 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>那能不能在 WebAssembly 中使用 JavaScript 寫的 function 呢？</h2>\n<p>當然可以！就是透過方才所說的第二個參數 <code class=\"language-text\">importObject</code>。</p>\n<p>假設我們想要在剛剛的加法函數內進行 JS 的 <code class=\"language-text\">console.log</code>：</p>\n<div class=\"gatsby-highlight\" data-language=\"cadd.c\"><pre class=\"language-cadd.c\"><code class=\"language-cadd.c\">#include &lt;math.h&gt;\nvoid consoleLog (int num);\nint add(int num1, int num2) {\n    int result = num1 + num2;\n    consoleLog(result);\n    return result;\n}</code></pre></div>\n<p>先宣告一個 <code class=\"language-text\">consoleLog</code> 函式，並不需要實作他，因為這會是我們待會要從 JavaScript 那邊 import 進來的部分：</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token function\">fetchAndInstantiateWasm</span><span class=\"token punctuation\">(</span><span class=\"token string\">'./add.wasm'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>\n    env<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function-variable function\">consoleLog</span><span class=\"token operator\">:</span> <span class=\"token parameter\">num</span> <span class=\"token operator\">=></span> console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>num<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">m</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    m<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token number\">5</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// console.log 8</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>在剛剛的 <code class=\"language-text\">fetchAndInstantiateWasm</code> 的第二個參數中，我們定義一個 <code class=\"language-text\">env</code> object，並傳入一個內含 console.log 的函式。<code class=\"language-text\">env</code> 是一個特殊的 key，在剛剛的 add.c 當中，我們宣告的 <code class=\"language-text\">void consoleLog (int num)</code> 轉換到 add.wast 時，他會當作這個函式是從 <code class=\"language-text\">env</code> 中 import 進入的（line 2）：</p>\n<div class=\"gatsby-highlight\" data-language=\"wastadd.wast\"><pre class=\"language-wastadd.wast\"><code class=\"language-wastadd.wast\">(module\n  (type $FUNCSIG$vi (func (param i32)))\n  (import &quot;env&quot; &quot;consoleLog&quot; (func $consoleLog (param i32)))\n  // ...函數內容省略，可參考前面的範例\n)</code></pre></div>\n<h3 id=\"難道只能從-env-載入嗎\" style=\"position:relative;\"><a href=\"#%E9%9B%A3%E9%81%93%E5%8F%AA%E8%83%BD%E5%BE%9E-env-%E8%BC%89%E5%85%A5%E5%97%8E\" aria-label=\"難道只能從 env 載入嗎 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>難道只能從 env 載入嗎？</h3>\n<p>當然不是，我們也可以自己定義，但就要去更改 wast 檔案了，其實改過以後會發現邏輯不難懂，有讓我回味到大學修組語的感覺...</p>\n<div class=\"gatsby-highlight\" data-language=\"wastadd-10-20.wast\"><pre class=\"language-wastadd-10-20.wast\"><code class=\"language-wastadd-10-20.wast\">(module\n  (type $FUNCSIG$vi (func (param i32)))\n  (import &quot;env&quot; &quot;consoleLog&quot; (func $consoleLog (param i32)))\n  ++(import &quot;lib&quot; &quot;log&quot; (func $log (param i32)))\n  (table 0 anyfunc)\n  (memory $0 1)\n  (export &quot;memory&quot; (memory $0))\n  (export &quot;add&quot; (func $add))\n  (func $add (param $0 i32) (param $1 i32) (result i32)\n    (call $consoleLog // 從 env 中載入的 consoleLog\n      ++(i32.add\n        (tee_local $1\n          (i32.add\n            (get_local $1)\n            (get_local $0)\n          )\n        )\n        ++(i32.const 20) // 從 env 載入的 consoleLog 將結果多加 20\n      )\n    )\n    ++(call $log // 從我們自己定義的 lib 中載入的 log\n      ++(i32.add\n        ++(get_local $1) // $1 + $0 的結果放到 $1 了，因此我們直接將 $1 + 10 即可。\n        ++(i32.const 10) // 從 lib 載入的 log 會將結果多加 10\n      ++)\n    ++)\n    (get_local $1)\n  )\n)</code></pre></div>\n<p>前面有加號的就是我們直接在 wast 中修改的程式碼，等同於如下 C 語言的程式：</p>\n<div class=\"gatsby-highlight\" data-language=\"cadd.c\"><pre class=\"language-cadd.c\"><code class=\"language-cadd.c\">#include &lt;math.h&gt;\nvoid consoleLog (int num);\nint add(int num1, int num2) {\n    int result = num1 + num2;\n    consoleLog(result + 20);\n    log(result + 10); // 多了這個從 lib 匯入的 log 函數\n    return result;\n}</code></pre></div>\n<p>如此一來，我們就能夠像下面這般傳遞 <code class=\"language-text\">lib.log</code> 給我們的 wasm 使用了！</p>\n<p><a class=\"jsbin-embed\" href=\"http://jsbin.com/mixure/embed?html,console\">WASM Test on jsbin.com</a><script src=\"http://static.jsbin.com/js/embed.min.js?4.0.4\"></script></p>\n<!-- 操作 memory -->\n<h2 id=\"現在我知道如何在-js-與-webassembly-中互相使用函式了但前面好像有提到他還能讓你操作-memory\" style=\"position:relative;\"><a href=\"#%E7%8F%BE%E5%9C%A8%E6%88%91%E7%9F%A5%E9%81%93%E5%A6%82%E4%BD%95%E5%9C%A8-js-%E8%88%87-webassembly-%E4%B8%AD%E4%BA%92%E7%9B%B8%E4%BD%BF%E7%94%A8%E5%87%BD%E5%BC%8F%E4%BA%86%E4%BD%86%E5%89%8D%E9%9D%A2%E5%A5%BD%E5%83%8F%E6%9C%89%E6%8F%90%E5%88%B0%E4%BB%96%E9%82%84%E8%83%BD%E8%AE%93%E4%BD%A0%E6%93%8D%E4%BD%9C-memory\" aria-label=\"現在我知道如何在 js 與 webassembly 中互相使用函式了但前面好像有提到他還能讓你操作 memory permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>現在我知道如何在 JS 與 WebAssembly 中互相使用函式了，但前面好像有提到他還能讓你操作 Memory?!</h2>\n<p>前面範例中的 wast 都有將 memory export 出來：<code class=\"language-text\">(export \"memory\" (memory $0))</code>\n我們可以利用前面提及的 JavaScript Typed Array 來取得 memory buffer，並利用 TextDecoder 這個較新的 Web API 來解碼：</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> memory <span class=\"token operator\">=</span> wasmModule<span class=\"token punctuation\">.</span>memory<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> strBuf <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Uint8Array</span><span class=\"token punctuation\">(</span>memory<span class=\"token punctuation\">.</span>buffer<span class=\"token punctuation\">,</span> wasmModule<span class=\"token punctuation\">.</span><span class=\"token function\">getStrOffset</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token number\">11</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> str <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">TextDecoder</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">decode</span><span class=\"token punctuation\">(</span>strBuf<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>str<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><a class=\"jsbin-embed\" href=\"http://jsbin.com/gewayo/embed?html,console\">JS Bin on jsbin.com</a><script src=\"http://static.jsbin.com/js/embed.min.js?4.0.4\"></script></p>\n<p>可以讀取到 memory，當然也能寫入：</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">writeString</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">str<span class=\"token punctuation\">,</span> offset</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">const</span> strBuf <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">TextEncoder</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">encode</span><span class=\"token punctuation\">(</span>str<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">const</span> outBuf <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Uint8Array</span><span class=\"token punctuation\">(</span>mem<span class=\"token punctuation\">.</span>buffer<span class=\"token punctuation\">,</span> offset<span class=\"token punctuation\">,</span> strBuf<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> strBuf<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        outBuf<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> strBuf<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span></code></pre></div>\n<p>對於 Memory 的操作部分，<a href=\"https://github.com/guybedford/wasm-intro\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Guy Bedford 的範例</a>有更多介紹，包含怎麼搭配 <code class=\"language-text\">malloc</code> 來動態調整記憶體。</p>\n<!-- 效能呈現 -->\n<h2 id=\"webassembly-對於效能的展現似乎到目前為止都沒有觸及耶\" style=\"position:relative;\"><a href=\"#webassembly-%E5%B0%8D%E6%96%BC%E6%95%88%E8%83%BD%E7%9A%84%E5%B1%95%E7%8F%BE%E4%BC%BC%E4%B9%8E%E5%88%B0%E7%9B%AE%E5%89%8D%E7%82%BA%E6%AD%A2%E9%83%BD%E6%B2%92%E6%9C%89%E8%A7%B8%E5%8F%8A%E8%80%B6\" aria-label=\"webassembly 對於效能的展現似乎到目前為止都沒有觸及耶 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>WebAssembly 對於效能的展現似乎到目前為止都沒有觸及耶？</h2>\n<p>要能夠展現 JavaScript 與 WebAssembly 的效能差異其實沒有那麼簡單，Guy Bedford 在影片中的範例是在螢幕上畫出多個圓圈，計算他們之間碰撞的狀況來移動，有趣的是，第一次的 Demo 中，JavaScript 的速度比 WebAssembly 實作碰撞計算的要快得多，然而在重新 optimize 演算法後，才讓 WebAssembly 的效能有大幅進展，比起 JavaScript 好上不少（同樣演算法）</p>\n<p>這邊放個動態截圖給大家看，想自己跑跑看或是看程式碼的可以移駕 Guy Bedford 的 repo - <a href=\"https://github.com/guybedford/wasm-demo\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Wasm Demo</a>，載下來直接就能打開 html 執行囉！(要執行這個 Demo 需要 Chrome Canary 並在 chrome://flags 中啟動 Experimental Web Platform Flag)</p>\n<p><img src=\"/image/wasmvsjs.gif\" alt=\"Wasm VS JS\"></p>\n<!-- ## 結論-->\n<h2 id=\"結論\" style=\"position:relative;\"><a href=\"#%E7%B5%90%E8%AB%96\" aria-label=\"結論 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>結論</h2>\n<p>目前 wasm 在 Chrome 與 firefox 都已實作，雖然一定還會有規格上的變更，但了解一下這個勢必會影響未來 Web 開發的東西是有必要的！</p>\n<p>本文也只是簡單介紹基礎的使用方法，實際上還有許多相關的議題，像是 <strong>Type Arrays</strong> 與 <strong>WebAssembly Web API</strong> 等等，都需要有所了解。甚至是如何將各種程式語言 compile 成 wasm 也是一門大學問，也有許多我沒有提及的工具可以使用（從資料來源中找得到）。</p>\n<p>希望大家看完後可以對 WebAssembly 的使用方式有點概念，文中若有不清楚或是錯誤的地方也歡迎指正！</p>\n<h2 id=\"資料來源\" style=\"position:relative;\"><a href=\"#%E8%B3%87%E6%96%99%E4%BE%86%E6%BA%90\" aria-label=\"資料來源 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>資料來源</h2>\n<ol>\n<li><a href=\"http://webassembly.org/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">WebAssembly.org</a></li>\n<li><a href=\"https://egghead.io/courses/get-started-using-webassembly-wasm\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Get Started Using WebAssembly (wasm)</a></li>\n<li><a href=\"https://github.com/WebAssembly/design\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">WebAssembly Design</a></li>\n<li><a href=\"https://www.w3.org/community/webassembly/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">W3C Community Group</a></li>\n<li><a href=\"https://www.w3ctech.com/topic/2024\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">WebAssembly 系列（四）WebAssembly 工作原理</a></li>\n<li><a href=\"https://github.com/guybedford/wasm-intro\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">guybedford/wasm-intro</a></li>\n<li><a href=\"https://github.com/guybedford/wasm-demo\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">guybedford/wasm-demo</a>)</li>\n</ol>","id":"388bb6fe-045e-5e70-ab4c-1443a6a3ae10","fields":{"slug":"webassembly-js-future"},"frontmatter":{"date":"2017-06-17T13:34:49.000Z","title":"[筆記] 了解 WebAssembly 的基礎使用方法","tags":["webassembly","javascript"],"type":"tech","slug":"webassembly-js-future"},"timeToRead":16},"next":{"excerpt":"『In theory, there is no difference between theory and practice. But, in practice, there is.』- Jan LA van de Snepscheut","html":"<blockquote>\n<p>『In theory, there is no difference between theory and practice. But, in practice, there is.』- Jan LA van de Snepscheut</p>\n</blockquote>\n<!-- more -->\n<h2 id=\"前言\" style=\"position:relative;\"><a href=\"#%E5%89%8D%E8%A8%80\" aria-label=\"前言 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>前言</h2>\n<p>HTML 5 的 Canvas 是許多人做動畫、做遊戲常常會用到的工具，此外，如果是進行資料視覺化，在繪製大量的圖形與動畫時，Canvas 可以為你的 performance 帶來很大的改善，從 <a href=\"http://blog.infographics.tw/2015/07/optimize-d3-with-canvas/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">D3.js 實戰 － Canvas 把我的視覺化變「快」了！</a> 中最後的範例就可以看得出來差異。</p>\n<p>總之，身為前端工程師的我卻沒有實作做過 Canvas 相關應用，在羞愧之餘也得奮發向上扳回劣勢才可以，所以決定把上次用 d3 與 svg 繪製的颱風路徑圖重新用 Canvas 重寫一遍，也透過這篇文章做個紀錄。</p>\n<h2 id=\"canvas-基礎概念---繪圖\" style=\"position:relative;\"><a href=\"#canvas-%E5%9F%BA%E7%A4%8E%E6%A6%82%E5%BF%B5---%E7%B9%AA%E5%9C%96\" aria-label=\"canvas 基礎概念   繪圖 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Canvas 基礎概念 - 繪圖</h2>\n<p>Canvas 顧名思義就是一塊畫布，只不過是生存在你的 HTML DOM tree 中，讓你透過 Javascript 在上面揮灑創意。</p>\n<p>Canvas 就像一般的 DOM 元素一樣，有 <code class=\"language-text\">width</code> 與 <code class=\"language-text\">height</code> 等屬性可以設定，也能透過 CSS 來操作他的樣式，而這些樣式並不會影響到你在上面所進行的任何繪製功能。\n不過要注意一下，如果你是透過 CSS 去更改寬度與高度，他會放大 Canvas 元素本身，而不會放大 Canvas 內的像素，因此你在 Canvas 內繪製的圖形可能會變形。</p>\n<p><code class=\"language-text\">&lt;canvas id=\"worldMapCanvas\" width=\"1000\" height=\"600\"> Your browser is too old... &lt;/canvas></code></p>\n<p>有了 Canvas 元素後，我們要取得他的 <strong>渲染環境（rendering context）</strong>，之後必須要透過這個 Context 才能進行繪圖：</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> canvas <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">getElementById</span><span class=\"token punctuation\">(</span><span class=\"token string\">'worldMapCanvas'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> ctx <span class=\"token operator\">=</span> canvas<span class=\"token punctuation\">.</span><span class=\"token function\">getContext</span><span class=\"token punctuation\">(</span><span class=\"token string\">'2d'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>接下來的一切繪圖操作就會跟著你取得的 context 進行，透過一連串 Canvas API，你可以繪製出如下的圖案：</p>\n<p data-height=\"374\" data-theme-id=\"29194\" data-slug-hash=\"brLmqX\" data-default-tab=\"js,result\" data-user=\"arvin0731\" data-embed-version=\"2\" data-pen-title=\"First demo - define graph\" class=\"codepen\">See the Pen <a href=\"https://codepen.io/arvin0731/pen/brLmqX/\">First demo - define graph</a> by Arvin (<a href=\"https://codepen.io/arvin0731\">@arvin0731</a>) on <a href=\"https://codepen.io\">CodePen</a>.</p>\n<script async src=\"https://production-assets.codepen.io/assets/embed/ei.js\"></script>\n<p>在 <code class=\"language-text\">ball.draw()</code> 這個函數當中，我用了五個最基本的 Canvas API 來進行繪製：</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\">    ctx<span class=\"token punctuation\">.</span><span class=\"token function\">beginPath</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    ctx<span class=\"token punctuation\">.</span><span class=\"token function\">arc</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>x<span class=\"token punctuation\">,</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>y<span class=\"token punctuation\">,</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>radius<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> Math<span class=\"token punctuation\">.</span><span class=\"token constant\">PI</span> <span class=\"token operator\">*</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    ctx<span class=\"token punctuation\">.</span><span class=\"token function\">closePath</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    ctx<span class=\"token punctuation\">.</span>fillStyle <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>color<span class=\"token punctuation\">;</span>\n    ctx<span class=\"token punctuation\">.</span><span class=\"token function\">fill</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<ul>\n<li>\n<p><code class=\"language-text\">ctx.beginPath()</code>:\n<a href=\"https://developer.mozilla.org/zh-TW/docs/Web/API/Canvas_API/Tutorial/Drawing_shapes\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">MDN</a> 上的說明是：產生一個新路徑，產生後再使用繪圖指令來設定路徑。\n白話一點就是告訴 Canvas 說你現在要開始繪製線段了喔！請幫我開啟一個新的次路徑清單（sub-path），幫忙紀錄接下來我繪製的路線。\n基本上在你每次繪製新的圖形或線段的時候，都需要呼叫一次 <code class=\"language-text\">beginPath()</code>，否則 Canvas 會將你先前的繪製的部分與後續你想繪製的新圖型當作同一個連續的圖。\n來個範例（沒有使用 beginPath() 就直接想繪製新圖形時）：</p>\n<p data-height=\"300\" data-theme-id=\"29194\" data-slug-hash=\"LjQgqg\" data-default-tab=\"js,result\" data-user=\"arvin0731\" data-embed-version=\"2\" data-pen-title=\"First demo - beginPath\" class=\"codepen\">See the Pen <a href=\"https://codepen.io/arvin0731/pen/LjQgqg/\">First demo - beginPath</a> by Arvin (<a href=\"https://codepen.io/arvin0731\">@arvin0731</a>) on <a href=\"https://codepen.io\">CodePen</a>.</p>\n<script async src=\"https://production-assets.codepen.io/assets/embed/ei.js\"></script>\n<p>可以發現我明明在 <code class=\"language-text\">lineTo()</code> 後有設定不同的 <code class=\"language-text\">strokeStyle</code>，但最後都被 <span style=\"color:#B90CB3\">#B90CB3</span> 給取代了，這就是因為沒有呼叫 beginPath 來對線段做區隔。</p>\n<p>加上 <code class=\"language-text\">beginPath()</code> 後，結果就會是我們想要的了：</p>\n<p data-height=\"300\" data-theme-id=\"29194\" data-slug-hash=\"ayqRMG\" data-default-tab=\"js,result\" data-user=\"arvin0731\" data-embed-version=\"2\" data-pen-title=\"First demo - addBeginPath\" class=\"codepen\">See the Pen <a href=\"https://codepen.io/arvin0731/pen/ayqRMG/\">First demo - addBeginPath</a> by Arvin (<a href=\"https://codepen.io/arvin0731\">@arvin0731</a>) on <a href=\"https://codepen.io\">CodePen</a>.</p>\n<script async src=\"https://production-assets.codepen.io/assets/embed/ei.js\"></script>\n</li>\n<li>\n<p><code class=\"language-text\">ctx.arc(x,y,raidus,startAngle,endAngle,counterclockwise)</code>:\n就是畫出一個弧線，前兩個參數設定中心點的位置，接著設定半徑、起始點（起始角度）、結束點（結束角度）與方向（順時針或逆時針：</p>\n<p><img src=\"/image/canvasarc.png\" alt=\"Canvas arc\"></p>\n</li>\n<li>\n<p><code class=\"language-text\">ctx.beginPath()</code> 的範例中還有用到 <code class=\"language-text\">moveTo()</code>, <code class=\"language-text\">lineTo()</code> 與 <code class=\"language-text\">stroke()</code>，也都是很常用的 API，但從字面上就很好理解:</p>\n<ul>\n<li>moveTo(x, y): 移動畫筆到 point x,y</li>\n<li>lineTo(x, y): 從現在畫筆位置畫一條直線到 point x,y（但光呼叫 <code class=\"language-text\">lineTo()</code> 還不會畫出線段，需透過 <code class=\"language-text\">stroke()</code> 等相似 API）</li>\n<li>stroke(): 實際下筆繪畫的 API</li>\n</ul>\n</li>\n<li><code class=\"language-text\">ctx.closePath()</code>:\nclosePath 其實在這邊不需要，他主要用途是在於幫你把你在 beginPath 後創建的 sub-path 做連接的動作，像是把第一條 path 的頭與最後一條 path 的尾巴接起來，但你也可以自己再多畫一條線將區域圍起來，只是稍嫌麻煩。\n從字面上來看，<code class=\"language-text\">closePath()</code> 很像是呼叫後就能幫你斷開路徑的連續性，保持後續繪製圖型的獨立性，但實際上沒有這個功用，你需要透過 <code class=\"language-text\">beginPath()</code> 來完成。</li>\n</ul>\n<p>還有很多 canvas API 的介紹都可以在 MDN 上查詢到，有的教學附有中文呦！<a href=\"https://developer.mozilla.org/zh-TW/docs/Web/API/Canvas_API/Tutorial\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">MDN Canvas tutorial</a></p>\n<h2 id=\"canvas-基礎概念---動畫\" style=\"position:relative;\"><a href=\"#canvas-%E5%9F%BA%E7%A4%8E%E6%A6%82%E5%BF%B5---%E5%8B%95%E7%95%AB\" aria-label=\"canvas 基礎概念   動畫 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Canvas 基礎概念 - 動畫</h2>\n<p>先前利用 D3 與 svg 做動畫時，是使用 <code class=\"language-text\">d3.timer</code> 來控制時間，並且更改 svg 元素的 attribute 來移動物件，進而達到動畫效果，但是在 Canvas 的世界中，沒有移動的這種概念，你如果想要讓一個在 Canvas 上的物件移動，你需要的是重新繪製在不同位置的物件，在快速的 frame update 下，人眼看到的就會是一連串動畫了。這原理就跟一般的影片與動畫相同，都是透過每一次 frame 的更新，來呈現出連續畫面。</p>\n<p>那要如何不斷地去更新 Canvas 呢？你可以透過 <code class=\"language-text\">setInterval</code> 也能夠用現在較為人知的 <code class=\"language-text\">requestAnimationFrame</code> 來處理，使用 <code class=\"language-text\">setInterval</code> 你可以直接控制動畫的更新速率，然而在效能上還是採用 <code class=\"language-text\">requestAnimationFrame</code> 較好，是以網頁頁面的更新速度為基準。</p>\n<p>一個採用 <code class=\"language-text\">requestAnimationFrame</code> 的簡單動畫如下：</p>\n<p data-height=\"300\" data-theme-id=\"29194\" data-slug-hash=\"yoovpx\" data-default-tab=\"js,result\" data-user=\"arvin0731\" data-embed-version=\"2\" data-pen-title=\"First demo\" class=\"codepen\">See the Pen <a href=\"https://codepen.io/arvin0731/pen/yoovpx/\">First demo</a> by Arvin (<a href=\"https://codepen.io/arvin0731\">@arvin0731</a>) on <a href=\"https://codepen.io\">CodePen</a>.</p>\n<script async src=\"https://production-assets.codepen.io/assets/embed/ei.js\"></script>\n<div class=\"gatsby-highlight\" data-language=\"jsdraw\"><pre class=\"language-jsdraw\"><code class=\"language-jsdraw\">    ctx.clearRect(0,0, canvas.width, canvas.height);\n    ball.draw();\n    // ... calculate position\n\n    raf = window.requestAnimationFrame(draw);</code></pre></div>\n<p>關鍵只有兩個地方：</p>\n<ul>\n<li>在每次 requestAnimationFrame 執行時，你都要清空現在的 Canvas 畫面重新繪製 <code class=\"language-text\">ctx.clearRect(0,0, canvas.width, canvas.height);</code>。</li>\n<li>requestAnimationFrame 是必須自己去呼叫的，所以在我們的 <code class=\"language-text\">draw()</code> 函式中，最後要自己呼叫 raf 來重新 trigger 自己的 draw function。\n你可以像一般的 setInterval 一樣記錄他回傳的 reference，並在適當時間 <code class=\"language-text\">cancelAnimationFrame</code>。</li>\n</ul>\n<h2 id=\"瞭解了-canvas-的基礎知識後可以開始動手今天的主題了\" style=\"position:relative;\"><a href=\"#%E7%9E%AD%E8%A7%A3%E4%BA%86-canvas-%E7%9A%84%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98%E5%BE%8C%E5%8F%AF%E4%BB%A5%E9%96%8B%E5%A7%8B%E5%8B%95%E6%89%8B%E4%BB%8A%E5%A4%A9%E7%9A%84%E4%B8%BB%E9%A1%8C%E4%BA%86\" aria-label=\"瞭解了 canvas 的基礎知識後可以開始動手今天的主題了 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>瞭解了 Canvas 的基礎知識後，可以開始動手今天的主題了！</h2>\n<p>由於範例是修改自 <a href=\"https://blog.arvinh.info/2017/07/21/d3-workshop-map/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">D3v4 工作坊 - React + D3 繪製 svg 動態路線地圖</a>，所以關於資料的取得與格式請參考該篇或是下面 Demo 的程式碼。</p>\n<h2 id=\"地圖\" style=\"position:relative;\"><a href=\"#%E5%9C%B0%E5%9C%96\" aria-label=\"地圖 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>地圖</h2>\n<p>在上一篇 <a href=\"https://blog.arvinh.info/2017/07/21/d3-workshop-map/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">D3v4 工作坊 - React + D3 繪製 svg 動態路線地圖</a> 中，我們利用 svg path 元素搭配 <code class=\"language-text\">d3.geoPath()</code> 與 <code class=\"language-text\">d3.geo</code> 中的 <code class=\"language-text\">geoMercator()</code> 來繪製世界地圖，那 d3 有辦法幫助我們在 Canvas 上繪製世界圖嗎?</p>\n<p>當然可以！</p>\n<p><code class=\"language-text\">d3.geoPath()</code> 有提供一個 <code class=\"language-text\">context()</code> API，讓你綁定 Canvas 的 context，然後就能傳入路徑資料繪製到 Canvas 上頭：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsrendermap\"><pre class=\"language-jsrendermap\"><code class=\"language-jsrendermap\">function renderMap() {\n  const self = this;\n  const canvasNode = d3Select(&#39;#mapCanvas&#39;).node();\n  const context = canvasNode.getContext(&#39;2d&#39;);\n  // 傳入 canvas context 給 geoPath()\n  const path = geoPath().context(context);\n  context.beginPath();\n  // 記得一樣要放入你的映射函數\n  path.projection(this.projection());\n  this.state.worlddata.features.forEach((d, i) =&gt; {\n      context.fillStyle = \n        &#39;rgba(38,50,56,&#39;+ 1 / this.state.worlddata.features.length * i + &#39;)&#39;\n      context.beginPath();\n      // 綁定 Canvas context 的 path 就能將傳入的資料繪製在 Canvas 上頭\n      path(d);\n      context.fill();\n  });\n\n  // add graticules path\n  context.beginPath();\n  path.projection(this.projection());\n  path(this.state.graticule);\n  context.fillStyle = &#39;none&#39;;\n  context.strokeStyle = &#39;#79A09E&#39;;\n  context.stroke();\n  }</code></pre></div>\n<p>Demo: （可以切換模式看 code，或是到<a href=\"https://blog.arvinh.info/2017/07/21/d3-workshop-map/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">上一篇</a>看，有許多重複的運算函式）</p>\n<iframe src=\"https://codesandbox.io/embed/w2lp7ml9vw?autoresize=1&view=preview\" style=\"width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;\" sandbox=\"allow-modals allow-forms allow-popups allow-scripts allow-same-origin\"></iframe>\n<h2 id=\"路徑\" style=\"position:relative;\"><a href=\"#%E8%B7%AF%E5%BE%91\" aria-label=\"路徑 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>路徑</h2>\n<p>接著重頭戲是要畫上路徑，這邊會複雜許多，我盡力說明，但直接看 code 會清楚一點。</p>\n<p>這邊說明在 Canvas 上繪製動態路線的原理與步驟：</p>\n<h3 id=\"線段動畫原理\" style=\"position:relative;\"><a href=\"#%E7%B7%9A%E6%AE%B5%E5%8B%95%E7%95%AB%E5%8E%9F%E7%90%86\" aria-label=\"線段動畫原理 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>線段動畫原理：</h3>\n<span style=\"color: red\">\n跟 svg 要製作動態路線一樣的原理，我們都是先將線畫好後，利用線段的 **line dash** 與 **dash offset** 來製作出路徑的動畫效果。（可參考 [上一篇](https://blog.arvinh.info/2017/07/21/d3-workshop-map/)）\n</span>\n<p>因此在繪製上的步驟也差不多，只是實作的細節不同罷了：</p>\n<ul>\n<li>Step 1. 繪製線段的入口點：</li>\n</ul>\n<p>既然一樣是利用 <strong>line dash</strong> 與 <strong>dash offset</strong>，那我們也就需要取得路徑的長度，才能夠設定 <code class=\"language-text\">lineDash</code> 麻，但是你如果在前面的範例中有打開過 devTool，就知道根本看不到 Canvas 上面你繪製的物件，每個線段也都是用各點的 x, y 值去連接，這樣要怎麼知道整個線段長呢？！</p>\n<p>難道要每一段每一段的線長度加總起來嗎？或許是個方法，但太麻煩了！</p>\n<p>我們可以直接利用 D3 創建一個 <code class=\"language-text\">invisiablePath</code>，然後透過 <code class=\"language-text\">getTotalLength()</code> 來取得線段長度，並利用在 Canvas 上頭！</p>\n<p><code class=\"language-text\">renderLine()</code> 是一切的起點，我們在這邊創建隱藏的 svg path 好計算長度，並呼叫 <code class=\"language-text\">requestAnimationFrame</code> 進行 loop，傳入 <code class=\"language-text\">updateLine</code> 函式來產生動畫。</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token function\">renderLine</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">canvasCtx<span class=\"token punctuation\">,</span> typhoonPath<span class=\"token punctuation\">,</span> marker<span class=\"token punctuation\">,</span> typhoonId</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> pathCoordinates <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    typhoonPath<span class=\"token punctuation\">.</span><span class=\"token function\">forEach</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">path</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n        pathCoordinates<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n            x<span class=\"token operator\">:</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">projection</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>path<span class=\"token punctuation\">.</span>coordinates<span class=\"token punctuation\">)</span><span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n            y<span class=\"token operator\">:</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">projection</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>path<span class=\"token punctuation\">.</span>coordinates<span class=\"token punctuation\">)</span><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">const</span> lineFunction <span class=\"token operator\">=</span> <span class=\"token function\">d3Line</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">.</span><span class=\"token function\">x</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">d</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> d<span class=\"token punctuation\">.</span>x<span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">.</span><span class=\"token function\">y</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">d</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> d<span class=\"token punctuation\">.</span>y<span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">.</span><span class=\"token function\">curve</span><span class=\"token punctuation\">(</span>curveCatmullRom<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// use svg path to get length</span>\n    <span class=\"token keyword\">const</span> invisiblePath <span class=\"token operator\">=</span> <span class=\"token function\">d3Select</span><span class=\"token punctuation\">(</span><span class=\"token string\">'svg'</span><span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">.</span><span class=\"token function\">append</span><span class=\"token punctuation\">(</span><span class=\"token string\">'g'</span><span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">.</span><span class=\"token function\">append</span><span class=\"token punctuation\">(</span><span class=\"token string\">'path'</span><span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">.</span><span class=\"token function\">attr</span><span class=\"token punctuation\">(</span><span class=\"token string\">'d'</span><span class=\"token punctuation\">,</span> <span class=\"token function\">lineFunction</span><span class=\"token punctuation\">(</span>pathCoordinates<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">.</span><span class=\"token function\">attr</span><span class=\"token punctuation\">(</span><span class=\"token string\">'fill'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'none'</span><span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">.</span><span class=\"token function\">attr</span><span class=\"token punctuation\">(</span><span class=\"token string\">'stroke'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'none'</span><span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">.</span><span class=\"token function\">attr</span><span class=\"token punctuation\">(</span><span class=\"token string\">'class'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'invisiblePath'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>invisibleSVGPath<span class=\"token punctuation\">[</span>typhoonId<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> invisiblePath<span class=\"token punctuation\">.</span><span class=\"token function\">node</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">const</span> length <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>invisibleSVGPath<span class=\"token punctuation\">[</span>typhoonId<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">getTotalLength</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// this clears itself once the line is drawn</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>lineInterval<span class=\"token punctuation\">[</span>typhoonId<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">requestAnimationFrame</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">updateLine</span><span class=\"token punctuation\">.</span><span class=\"token function\">bind</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> canvasCtx<span class=\"token punctuation\">,</span> typhoonPath<span class=\"token punctuation\">,</span> length<span class=\"token punctuation\">,</span> marker<span class=\"token punctuation\">,</span> typhoonId<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span></code></pre></div>\n<ul>\n<li>Step 3. 更新線段的函式：</li>\n</ul>\n<p>在每一次 requestAnimationFrame trigger 的時候，我們都會呼叫 <code class=\"language-text\">updateLine()</code> 來重新 render canvas，主要進行幾個步驟：</p>\n<ol>\n<li><code class=\"language-text\">defineLine()</code>，定義線段，每一次的 loop 都需要重新繪製線段。<a href=\"#step4\"> 跳至 Step 4 看詳細實作</a></li>\n<li>計算目前 <code class=\"language-text\">progress</code>，也就是目前 line offset 要調整到何處，我們是定義一個變數 <code class=\"language-text\">this.speed</code> 與 <code class=\"language-text\">this.dir</code> 來控制線段繪製的方向與速度。每一次的 loop 都會增加 <code class=\"language-text\">this.progress</code> 的值，然後丟入 <code class=\"language-text\">this.moveDash()</code> 中來繪製線段的 line dash 與 line dash offset。<a href=\"#step5\"> 跳至 Step 5 看詳細實作</a></li>\n<li>最後，每一次呼叫 <code class=\"language-text\">updateLine</code> 時，我們都會檢查 <code class=\"language-text\">this.progress</code> 是否已經與線段長度相同，代表已經走完一次路線，需要重新開始，這時候我們就需要先將 canvas 清空：<code class=\"language-text\">canvasCtx.clearRect(0,0,1000,600)</code>，表示將 canvasCtx 所持有的渲染環境從位置 (0,0) 開始對寬 1000 與高 600 的 canvas 清空。最後可以利用 <code class=\"language-text\">setTimoue()</code> 來延長一下路徑走完後的時間，讓他不要馬上就清空 canvas 重繪。</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"jsupdateline\"><pre class=\"language-jsupdateline\"><code class=\"language-jsupdateline\">updateLine(canvasCtx, typhoonPath, length, marker, typhoonId) {\n    // define the line\n    this.defineLine(canvasCtx, typhoonPath, marker, typhoonId);\n    this.progress[typhoonId] = this.progress[typhoonId] || 0;\n    if (this.progress[typhoonId] &lt; length) {\n      this.progress[typhoonId] += this.speed;\n      this.moveDash(canvasCtx, typhoonId, typhoonPath, length, marker, this.progress[typhoonId], this.dir);\n      requestAnimationFrame(this.updateLine.bind(this, canvasCtx, typhoonPath, length, marker, typhoonId));\n    } else {\n    \n      canvasCtx.clearRect(0, 0, 1000, 600);\n      this.progress[typhoonId] = 0;\n      setTimeout(() =&gt; requestAnimationFrame(this.updateLine.bind(this, canvasCtx, typhoonPath, 500, marker, typhoonId)), 1000);\n    }\n  }</code></pre></div>\n<ul>\n<li><span id=\"step4\" style=\"\">Step 4. 定義線段的函式：</span></li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"jsdefineline\"><pre class=\"language-jsdefineline\"><code class=\"language-jsdefineline\">defineLine(canvasCtx, typhoonPath, marker, typhoonId) {\n  // define path\n  canvasCtx.beginPath();\n  // start point\n  const startPoint = {\n    x: this.projection()(marker.coordinates)[0],\n    y: this.projection()(marker.coordinates)[1],\n  };\n  // 移動畫筆到起始點\n  canvasCtx.moveTo(startPoint.x, startPoint.y);\n\n  // 將路徑中的每個點與點之間用 lineTo() 連接起來\n  typhoonPath.forEach((path) =&gt; {\n      const x = this.projection()(path.coordinates)[0];\n      const y = this.projection()(path.coordinates)[1];\n      canvasCtx.lineTo(x, y);\n  });\n  // 設定 style\n  canvasCtx.lineWidth = 2;\n  canvasCtx.strokeStyle = &#39;rgba(53, 247, 14,0.7)&#39;;\n}</code></pre></div>\n<ul>\n<li><span id=\"step5\" style=\"\">Step 5. 實作更新 LineDash 的函式：</span></li>\n</ul>\n<p>單純的 moveDash 很簡單，只要透過 <code class=\"language-text\">setLineDash()</code>，將線段長度傳入，定義好你的 line dash 要多長，接著我們利用 Step 3 中提到的 <code class=\"language-text\">this.speed</code> 與 <code class=\"language-text\">this.dir</code> 來計算出現在要將 <code class=\"language-text\">lineDashOffset</code> 設為多少。</p>\n<p>這邊有個有趣的 API，<code class=\"language-text\">globalCompositeOperation</code>，它可以用來決定你目前的 canvas context 渲染環境中，每個新繪製的物件與其他舊有的物件之間的階層關係，像是我這邊設置的 <code class=\"language-text\">destination-over</code> 就代表 <strong>新繪製的圖形會被壓在舊的圖形下方</strong>，至於為什麼我這邊要設置這個參數呢？待會介紹颱風圈實作時你就知道了！更多關於 <code class=\"language-text\">globalCompositionOperation</code> 的介紹可以看 <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">MDN globalCompositeOperation</a></p>\n<div class=\"gatsby-highlight\" data-language=\"jsmovedash\"><pre class=\"language-jsmovedash\"><code class=\"language-jsmovedash\">moveDash = (canvasCtx, typhoonId, typhoonPath, length, marker, frac, dir = -1) =&gt; {\n  // default direction right-&gt;left\n  // 設定 line dash 為線段長\n  canvasCtx.setLineDash([length]);\n  // 利用 `this.progress (frac)` 來慢慢增加 line-dash offset，製作出線段動態\n  canvasCtx.lineDashOffset = dir * (frac + length);\n  canvasCtx.globalCompositeOperation = &#39;destination-over&#39;;\n  canvasCtx.stroke();\n}</code></pre></div>\n<p>到這裡為止，你已經創建出與上次相同的動態路線地圖，只是是採用 Canvas 實作，Demo：</p>\n<iframe src=\"https://codesandbox.io/embed/4j3r5yv74w?view=preview\" style=\"width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;\" sandbox=\"allow-modals allow-forms allow-popups allow-scripts allow-same-origin\"></iframe>\n<h2 id=\"暴風圈\" style=\"position:relative;\"><a href=\"#%E6%9A%B4%E9%A2%A8%E5%9C%88\" aria-label=\"暴風圈 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>暴風圈</h2>\n<p>當然不能單純只有線段，還是需要有個跟著線段跑的颱風才比較有 fu。</p>\n<p>你可以會想說，那就每次 <code class=\"language-text\">moveDash()</code> 執行的時候，順便也繪製上一個圓形的暴風圈不就好了嗎？</p>\n<p>接著就這麼做了：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsmovedash\"><pre class=\"language-jsmovedash\"><code class=\"language-jsmovedash\">moveDash = (canvasCtx, typhoonId, typhoonPath, length, marker, frac, dir = -1) =&gt; {\n  // default direction right-&gt;left\n  /* 原本繪製線段的部分 ... */\n  // ...\n  // ..\n  // Move typhoon marker\n  canvasCtx.beginPath();\n  canvasCtx.setLineDash([0]);\n  canvasCtx.lineDashOffset = 0;\n  canvasCtx.lineWidth = 1;\n  canvasCtx.strokeStyle = &#39;rgba(53, 247, 14,0.8)&#39;;\n  canvasCtx.arc(p.x, p.y, 10, 0, Math.PI * 2, true);\n  canvasCtx.closePath();\n  canvasCtx.stroke();\n}</code></pre></div>\n<p>然後就看到下面這個悲劇：</p>\n<iframe src=\"https://codesandbox.io/embed/xjz4n92yq4?view=preview\" style=\"width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;\" sandbox=\"allow-modals allow-forms allow-popups allow-scripts allow-same-origin\"></iframe>\n<p>其實也沒有錯，你的確是畫上圈圈了，但是每一次的 moveDash() 都會畫上一個圈圈，並且會持續留在 Canvas 上，而實際上我們應該每一步都要將前一個圈圈刪除。</p>\n<p>但如果你在這邊加上 <code class=\"language-text\">canvasCtx.clearRect(0, 0, 1000, 600);</code>，就會發現圈圈會正常移動了，但線段不見了...因為 <code class=\"language-text\">moveDash()</code> 並沒有重新繪製線段，只有更改 context 的 line dash。</p>\n<p><img src=\"/image/typhooncircleonly.gif\" alt=\"只剩下圈圈了...\"></p>\n<h3 id=\"解法\" style=\"position:relative;\"><a href=\"#%E8%A7%A3%E6%B3%95\" aria-label=\"解法 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>解法</h3>\n<p>那就多畫一層 Canvas 吧！</p>\n<p>沒有人說過 Canvas 只能有一層，你可以疊加一層 Canvas 上去，讓跟著線段移動的暴風圈獨自一個圖層，這樣一來就不會互相影響了！</p>\n<div class=\"gatsby-highlight\" data-language=\"jsmovedash-multilayer\"><pre class=\"language-jsmovedash-multilayer\"><code class=\"language-jsmovedash-multilayer\">moveDash = (canvasCtx, canvasTyphoonMarkerCtx, typhoonId, typhoonPath, length, marker, frac, dir = -1) =&gt; {\n  // default direction right-&gt;left\n  canvasCtx.setLineDash([length]);\n  canvasCtx.lineDashOffset = dir * (frac + length);\n  canvasCtx.globalCompositeOperation = &#39;destination-over&#39;;\n  canvasCtx.stroke();\n  const p = this.invisibleSVGPath[typhoonId].getPointAtLength(frac);\n  canvasCtx.save();\n  // Move typhoon marker\n  canvasTyphoonMarkerCtx.clearRect(0, 0, 1000, 600);\n  canvasTyphoonMarkerCtx.beginPath();\n  canvasTyphoonMarkerCtx.setLineDash([0]);\n  canvasTyphoonMarkerCtx.lineDashOffset = 0;\n  canvasTyphoonMarkerCtx.lineWidth = 1;\n  canvasTyphoonMarkerCtx.strokeStyle = &#39;rgba(53, 247, 14,0.8)&#39;;\n  canvasTyphoonMarkerCtx.arc(p.x, p.y, 10, 0, Math.PI * 2, true);\n  canvasTyphoonMarkerCtx.closePath();\n  canvasTyphoonMarkerCtx.stroke();\n}</code></pre></div>\n<p><code class=\"language-text\">const p = this.invisibleSVGPath[typhoonId].getPointAtLength(frac);</code> 這邊我們先前創立的 <code class=\"language-text\">invisibleSVGPath</code> 又登場了，用來取得目前的線段點資料。</p>\n<p>Demo: 利用兩層 Canvas 來實作跟著線段移動的暴風圈：</p>\n<iframe src=\"https://codesandbox.io/embed/0xoy5yn4rp?view=preview\" style=\"width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;\" sandbox=\"allow-modals allow-forms allow-popups allow-scripts allow-same-origin\"></iframe>\n<h2 id=\"最後-demo---加上時間判斷顏色區別多個颱風的情況\" style=\"position:relative;\"><a href=\"#%E6%9C%80%E5%BE%8C-demo---%E5%8A%A0%E4%B8%8A%E6%99%82%E9%96%93%E5%88%A4%E6%96%B7%E9%A1%8F%E8%89%B2%E5%8D%80%E5%88%A5%E5%A4%9A%E5%80%8B%E9%A2%B1%E9%A2%A8%E7%9A%84%E6%83%85%E6%B3%81\" aria-label=\"最後 demo   加上時間判斷顏色區別多個颱風的情況 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>最後 Demo - 加上時間判斷、顏色區別、多個颱風的情況：</h2>\n<iframe src=\"https://codesandbox.io/embed/98816jkovr?view=preview\" style=\"width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;\" sandbox=\"allow-modals allow-forms allow-popups allow-scripts allow-same-origin\"></iframe>\n<p>這邊還要注意一下，稍早提到的 <code class=\"language-text\">globalCompositeOperation</code>，如果你設為 <code class=\"language-text\">source-over</code>，也就是新繪製出的物件蓋在舊的上面的話，你就會發現颱風圈都被壓在線段下了！</p>\n<p><img src=\"/image/circleunderline.png\" alt=\"source-over\"></p>\n<p>因為在 moveDash 中，線段是一直在重新繪製的，而你留下的颱風圈相對就是舊的物件，所以記得要改成 <code class=\"language-text\">destinatioin-over</code> 才能有比較好的效果！</p>\n<h2 id=\"根據時間留下暴風圈\" style=\"position:relative;\"><a href=\"#%E6%A0%B9%E6%93%9A%E6%99%82%E9%96%93%E7%95%99%E4%B8%8B%E6%9A%B4%E9%A2%A8%E5%9C%88\" aria-label=\"根據時間留下暴風圈 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>根據時間留下暴風圈</h2>\n<p>這實作方法很簡單，就是在 moveDash 中判斷該點的時間，若符合要求就繪製上一個圖案即可，有興趣的讀者可以直接從 code 中看到。</p>\n<h2 id=\"如何讓所有動畫都結束後才一起重播\" style=\"position:relative;\"><a href=\"#%E5%A6%82%E4%BD%95%E8%AE%93%E6%89%80%E6%9C%89%E5%8B%95%E7%95%AB%E9%83%BD%E7%B5%90%E6%9D%9F%E5%BE%8C%E6%89%8D%E4%B8%80%E8%B5%B7%E9%87%8D%E6%92%AD\" aria-label=\"如何讓所有動畫都結束後才一起重播 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>如何讓所有動畫都結束後才一起重播？</h2>\n<p>在我最後一個 Demo 中，一個颱風的路徑較短，一個較長，但卻能同時重播，我採用的方法其實蠻愚蠢的，暫時還沒想到更好的解法，歡迎大家提供。</p>\n<p>我的方法是，用一個共有變數 <code class=\"language-text\">this.allDone</code> 來記錄每條路徑是否已經播完動畫（走完整條 path），接著在 <code class=\"language-text\">updateLine()</code> 中，當自己跑完 path 時，就會多檢查一下 <code class=\"language-text\">this.allDone</code> 中的結果，如果還有人在跑，那自己就繼續呼叫 requestAnimationFrame，但不將 Canvas 清空，所以會一直 loop 檢查 <code class=\"language-text\">this.allDone</code>，直到大家都跑完才清空 Canvas 並重新 loop。</p>\n<div class=\"gatsby-highlight\" data-language=\"jsupdateline-multiple\"><pre class=\"language-jsupdateline-multiple\"><code class=\"language-jsupdateline-multiple\">if (this.progress[typhoonId] &lt; length) {\n   // 正常執行 defineLine 與 moveDash\n} else {\n  // 不斷檢查是否每條 path 都跑完了\n  this.allDone[typhoonId] = true;\n  let keepWaiting;\n  Object.keys(this.allDone).forEach((allDoneTyphoonId) =&gt; {\n    if (!this.allDone[allDoneTyphoonId]) {\n        keepWaiting = true;\n    }\n    return keepWaiting;\n  });\n  if (keepWaiting) {\n    requestAnimationFrame(this.updateLine.bind(this, canvasCtx, canvasTyphoonMarkerCtx, typhoonPath, 500, marker, typhoonId));\n  } else {\n    // 清空 canvas 並重新 loop\n  }\n}</code></pre></div>\n<h2 id=\"結論\" style=\"position:relative;\"><a href=\"#%E7%B5%90%E8%AB%96\" aria-label=\"結論 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>結論</h2>\n<p>利用 Canvas 繪製動畫實際上比用 D3 + svg 煩瑣多了，但是當你的動畫有大量的物件時，Canvas 能為你帶來大幅的 performance 改進，畢竟 svg 的操作會直接影響到 DOM tree。\n另外，實際上要將這些東西應用到 Production 的話，其實還有非常多細節要調整，包含各種 Browser 與 Device 的呈現、Map Scale 的彈性等等，還有很長的路要走啊...\n這篇文章算是我的一個筆記，寫得有點雜亂，歡迎（有看完的或是看不下去的）讀者給予任何建議！\n(PS. 我本來路徑跟暴風圈的顏色是想弄得像 EVA 風格，結果有點慘XD  但我懶得修了就給大家笑笑～)</p>\n<h2 id=\"資料來源\" style=\"position:relative;\"><a href=\"#%E8%B3%87%E6%96%99%E4%BE%86%E6%BA%90\" aria-label=\"資料來源 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>資料來源</h2>\n<ol>\n<li><a href=\"https://css-tricks.com/svg-line-animation-works/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">How SVG Line Animation Works</a></li>\n<li><a href=\"http://blog.infographics.tw/2015/07/optimize-d3-with-canvas/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">D3.js 實戰 － Canvas 把我的視覺化變「快」了！</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-TW/docs/Web/API/Canvas_API/Tutorial\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">MDN Canvas tutorial</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">MDN globalCompositeOperation</a></li>\n<li><a href=\"https://bl.ocks.org/mbostock/3783604\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">mbostock d3.geoPath + Canvas</a></li>\n</ol>","id":"1b0e7d88-3ed4-5c1e-8c8d-f1857d0cfea8","fields":{"slug":"canvas-path-map"},"frontmatter":{"date":"2017-08-18T00:04:21.000Z","title":"D3v4 & Canvas 工作坊 - D3 + Canvas 繪製動態路線圖","tags":["javascript","d3","d3v4","canvas"],"type":"tech","slug":"canvas-path-map"},"timeToRead":17},"type":"tech"}},"staticQueryHashes":["2123680655"]}