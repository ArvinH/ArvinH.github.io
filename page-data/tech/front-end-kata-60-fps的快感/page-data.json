{"componentChunkName":"component---src-templates-post-tsx","path":"/tech/front-end-kata-60-fps的快感","result":{"data":{"markdownRemark":{"html":"<blockquote>\n<p>\"My name is Barry Allen, and I'm the fastest man alive ...\"\n\"Wait..reverse flash is faster then you, zoom is faster than you..\"</p>\n</blockquote>\n<!-- more -->\n<p>今天來談談Browser Rendering Optimisation。順便也是為在公司上的課做個心得記錄。</p>\n<p>相信大家小時候都好奇過早期的電影、卡通或動畫，是怎麼樣製作出來的，而我們也都知道基本上就是一連串的<code class=\"language-text\">畫面</code>以非常快速的方式做切換，矇騙你的視覺讓你感受到是連續的<code class=\"language-text\">影片</code>，而Browser其實也是類似的做法，當取得Server的回應後，瀏覽器便把接收到的HTML畫出來，而每當你的網頁有所變化時，Browser就會再依據其邏輯將網頁重新渲染一遍，也因此才能看到這麼多漂亮的效果。</p>\n<p>而所謂browser rendering optimization就是要讓渲染的過程能夠更快速、更順暢，讓你的網頁畫面如夢似幻、細緻耀眼。</p>\n<p>要做到這件事情，就必須提及FPS(Frames per Second)，顧名思義就是每秒畫幾個Frames，一般影片大概是<a href=\"https://en.wikipedia.org/wiki/Frame_rate\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">30fps</a>，而多數螢幕畫面的更新頻率是60Hz，因此若我們能將fps極致提升到60fps，理當能有非常棒的畫面呈現！</p>\n<p>知道目標後，let's do some math...\n<code class=\"language-text\">60fps = 60 frames per second = 60 frames every 1000ms</code>\n好的從我們優異的數學能力下得知，要達到60fps，我們繪製一個frames的時間必須在16.6666...ms左右(1000/60)</p>\n<p>ok，那要怎麼知道自己的網頁每個frames花了多少時間繪製？拜Google大神所賜，只要打開Chrome的devTool，切換到Timeline的tab，就可以很容易的知道網頁在browser上的render時間。讓我們用畫面超級old school的pchome拍賣來Demo一下：</p>\n<p><img src=\"/image/googleDevTool-pchome.png\" alt=\"Devtool-timeline(點圖放大)\" title=\"DevTool-timeline\"></p>\n<p>先別被圖中五顏六色的區塊嚇到，在我們說明這Tool該如何使用之前，必須先瞭解Browser的Render過程，以及這圖片中每個顏色所代表的意義。</p>\n<p>接觸過HTML的人一定都知道所謂的DOM Tree，Browser會解析HTML並轉換成DOM Tree做操作，但知道<a href=\"https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-tree-construction?hl=en\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Render Tree</a>的人可能就不多了，Render tree由DOM tree與CSS結合產生，Browser就是依照Render Tree來決定該在畫面上呈現什麼東西。若你今天在某個div的css上加上<code class=\"language-text\">display: none</code>，那這個div就不會再Render tree上呈現。</p>\n<p><img src=\"/image/RenderTree.png\" alt=\"Render Tree (source from google)\"></p>\n<p>既然Render的過程也是一棵Tree，有點概念的人可能會想：每次style改變或是我更動DOM的位置時，這棵Tree也就會變動了吧？\n沒錯！在整個Browser的Render過程中，就是會不斷去recalculating style、layout的關係，來建構這棵樹。</p>\n<p>當然Browser的渲染過程不止這些，還必須載入js, css, web api等等的資源，因此有所謂的Rendering Pipeline</p>\n<p><img src=\"/image/render_pipeline.png\" alt=\"Render Pipeline (source from google)\">\n從圖上可以發現其順序為：</p>\n<ol>\n<li>Javascript: 載入與執行JS/CSS</li>\n<li>Style: 根據js與css計算style</li>\n<li>Layout: 當style套入元素時，瀏覽器要檢查是否會影響到整個畫面的排列，並進行排列</li>\n<li>Paint: 排列後有更動到的元素需要重新繪製（第一次載入的話當然是全部繪製）</li>\n<li>Composite: 最後就是將所有元素重新合成回來（重新繪製的元素與原本的元素）</li>\n</ol>\n<p>實際上並非每次的前端更動都會執行這五個步驟，若你只有切換顏色、圖片等不影響版面配置的動作，browser會跳過Layout，直接進行Paint；或著你捲動網頁、css的動畫效果，這類操作則會跳過style與layout，直接進行Composite。</p>\n<p>接下來我們回到Timeline這個tool。</p>\n<p><img src=\"/image/Timeline2.png\" alt=\"Timeline record\">\n你可以直接在你想觀察的網頁打開Timeline，並重新整理，他就會自行錄製；或是你可以在你想觀察的操作步驟進行前（ex. 滑動頁面、打開menu bar等等）按下錄製。</p>\n<p><img src=\"/image/Timeline3.png\" alt=\"Timeline finish\"></p>\n<p>接著在你覺得適合的地方（通常就是步驟執行完後）按下Finish。</p>\n<p><img src=\"/image/Timeline1.png\" alt=\"Timeline result\"></p>\n<p>基本上就能得到下列的Timeline結果。\n從這張圖片可以清楚看到每個frame花了多少時間，在Render pipeline中發生了哪些事情，值得注意的是，圖片右上角有個紅色小三角形，若你的frame中有這個標記，就代表Chrome認為這段frame有可以改善的部分。大家不妨到自己的網頁打開Timeline，看看有多少東西需要改進XD</p>\n<p>在認識了工具後，總是要實際操作一遍才會有感受，這邊以三種角度來進行Optimization。</p>\n<h2 id=\"javascript\" style=\"position:relative;\"><a href=\"#javascript\" aria-label=\"javascript permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Javascript</h2>\n<p>一般來說，前端工程師常常會利用<code class=\"language-text\">setTimeout</code>或是<code class=\"language-text\">setInterval</code>來製作一些動畫效果，你可能會寫下面這樣的code:</p>\n<p><a href=\"https://jsbin.com/xuconawipi/5/edit?html,js,output\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">example setInterval</a></p>\n<div class=\"gatsby-highlight\" data-language=\"javascriptsetinterval.js\"><pre class=\"language-javascriptsetinterval.js\"><code class=\"language-javascriptsetinterval.js\">var timer = {time: 0};\nfunction counter(timer) { \n  timer.time = timer.time+1;\n  document.querySelector(&quot;#counter&quot;).innerHTML = timer.time;\n}\nsetInterval(counter.bind(null,timer), 1000); </code></pre></div>\n<p>或著是</p>\n<p><a href=\"https://jsbin.com/yocokorelu/edit?html,js,output\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">example setTimeout</a></p>\n<div class=\"gatsby-highlight\" data-language=\"javascriptsettimeout.js\"><pre class=\"language-javascriptsettimeout.js\"><code class=\"language-javascriptsettimeout.js\">\t\tvar timer = {time: 0};\n\t\tfunction counter(timer) { \n\t\t\tsetTimeout(counter.bind(null,timer), 1000);\n\t\t\ttimer.time = timer.time+1;\n\t\t\tdocument.querySelector(&quot;#counter&quot;).innerHTML = timer.time;\n\t\t}\n\t\tcounter(timer);</code></pre></div>\n<p>兩者都可以讓你達到同樣的效果，但是setTimeout跟setInterval對Browser來說都有個主要缺點，就是他<strong><span style=\"color:red; font-style: italic;\">想執行時就會執行，而不會依據你的Browser狀況<span></strong>；另外當你切換到別的Tab時，setTimeout還會繼續Render。（理論上user看不到畫面，Browser就可以不用執行，以節省效能）\n<em><span style=\"color:rgba(228, 85, 85, 0.81); font-style: italic;\">不過現在許多瀏覽器都已經利用某些方式讓setTimeout在不需要Render時暫停工作。</span></em></p>\n<p>除了setTimeout與setInterval外，我們其實還有另一個選擇 <span style=\"color:red;\"><code class=\"language-text\">requestAnimationFrame</code></span></p>\n<p>假設我們有個Draw的動畫function，用setTimeout是這樣實作：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascriptdraw.js\"><pre class=\"language-javascriptdraw.js\"><code class=\"language-javascriptdraw.js\">\t\tfunction draw() {\n\t\t    setTimeout(draw, 16); // 16ms per frame!\n\t\t    // Drawing\n\t\t}\n\t\tdraw();</code></pre></div>\n<p>若是用requestAnimationFrame：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascriptdraw-raf.js\"><pre class=\"language-javascriptdraw-raf.js\"><code class=\"language-javascriptdraw-raf.js\">\t\tfunction draw() {\n\t\t\t// Drawing\n\t\t\trequestAnimationFrame(draw);\n\t\t}\n\t\trequestAnimationFrame(draw);</code></pre></div>\n<p>就這麼簡單，用了<span style=\"color:red;\"><code class=\"language-text\">requestAnimationFrame</code></span>之後，Browser就會綜合考量javascript所產生的動畫，一起刷新螢幕，並在動畫不在viewport時，暫停工作，以節省資源。</p>\n<p>當然你會想說，那如果我想控制animation的timing怎麼辦？以前面的counter例子來看，你可以這樣做：</p>\n<p><a href=\"https://jsbin.com/qerude/edit?html,js,output\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">example reqeustAnimationFrame</a></p>\n<div class=\"gatsby-highlight\" data-language=\"javascriptraf_timeer\"><pre class=\"language-javascriptraf_timeer\"><code class=\"language-javascriptraf_timeer\">\t\tvar timer = {time: 0};\n\t\tfunction counter(timer) { \n\t\t  setTimeout(function(){\n\t\t    requestAnimationFrame(counter.bind(null, timer));\n\t\t    timer.time = timer.time+1;\n\t\t    document.querySelector(&quot;#counter&quot;).innerHTML = timer.time;\n\t\t  }, 1000);\n\t\t}\n\t\tcounter(timer);</code></pre></div>\n<h2 id=\"style--layout\" style=\"position:relative;\"><a href=\"#style--layout\" aria-label=\"style  layout permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Style &#x26; Layout</h2>\n<p>除了JS外，在頁面上操作畫面大多免不了觸發<code class=\"language-text\">Style</code> &#x26; <code class=\"language-text\">Layout</code>這兩個Render Pipeline的步驟。既然免不了這些步驟，我們能做的就是盡量<strong>減少</strong>這些步驟的產生，大家可以到這裡（<a href=\"http://gent.ilcore.com/2011/03/how-not-to-trigger-layout-in-webkit.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">How (not) to trigger a layout in WebKit</a>）看看在有哪些操作我們要盡量減少。</p>\n<p>當然，光說不練感受不到差別，讓我們來練習一個例子：</p>\n<p><a href=\"https://jsbin.com/yesika/edit?html,css,js,output\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">example Layout trigger</a></p>\n<div class=\"gatsby-highlight\" data-language=\"javascriptbefor-optimization.js\"><pre class=\"language-javascriptbefor-optimization.js\"><code class=\"language-javascriptbefor-optimization.js\">\t\t(function() {\n\t\t  // noprotect\n\t\t  var sizer = document.querySelector(&#39;.sizer&#39;);\n\n\t\t  document.querySelector(&#39;.set-size&#39;).addEventListener(&#39;click&#39;, function(event) {\n\t\t    var ps = document.querySelectorAll(&#39;.article .article-block&#39;);\n\t\t    var i = ps.length;\n\t\t    var size;\n\t\t    while (i--) {\n\t\t      finalHeight = sizer.offsetHeight;\n\t\t      ps[i].style.height = finalHeight + &#39;px&#39;;\n\t\t    }\n\t\t    event.preventDefault();\n\t\t  });\n\t\t}());</code></pre></div>\n<p><a href=\"https://jsbin.com/wukuzi/2/edit?html,css,js,output\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">example Less Layout trigger</a></p>\n<div class=\"gatsby-highlight\" data-language=\"javascriptafter-optimization\"><pre class=\"language-javascriptafter-optimization\"><code class=\"language-javascriptafter-optimization\">\t\t(function() {\n\t\t  // noprotect\n\t\t  var sizer = document.querySelector(&#39;.sizer&#39;);\n\n\t\t  document.querySelector(&#39;.set-size&#39;).addEventListener(&#39;click&#39;, function(event) {\n\t\t    var ps = document.querySelectorAll(&#39;.article .article-block&#39;);\n\t\t    var i = ps.length;\n\t\t    var size;\n\t\t    var finalHeight = sizer.offsetHeight;\n\t\t    while (i--) {\n\t\t      ps[i].style.height = finalHeight + &#39;px&#39;;\n\t\t    }\n\t\t    event.preventDefault();\n\t\t  });\n\t\t}());</code></pre></div>\n<p>仔細看就會發現其實只有一行code有變動，效果卻差很多！當你在操作類似DOM物件的時候可以參考上述的網站，避免不必要的re-layout動作。</p>\n<h2 id=\"composite\" style=\"position:relative;\"><a href=\"#composite\" aria-label=\"composite permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Composite</h2>\n<p>在一個網頁的頁面當中，實際上並非是平面的，通常會由許多<code class=\"language-text\">Layer</code>所組成，而在Browser rendering pipeline的最後一個步驟<code class=\"language-text\">Composite</code>中，就是負責將這些Layer組合成完整的頁面。</p>\n<p>我們這次以最近Live直播統一獅頗為熱門的Yahoo首頁為例子，依照先前的方式打開Dev tool中的Timeline，選取其中一段frame後，點選下方的<code class=\"language-text\">Layers</code>標籤，應該就可以看到類似下面的圖：\n<img src=\"/image/layer.png\" alt=\"Composite Layers\">\n<img src=\"/image/compositeLayers.png\" alt=\"Composite Layers (而在Timeline的工具中，旁邊還能讓你拖拉旋轉，方便查看各個Layer的狀況。)\"></p>\n<p>可以發現yahoo首頁也是由許多層Layer所組成。</p>\n<p>眼尖的讀者可能會發現為什麼頁面中只有一個區塊是綠色的？這就是這小節的重點了，在Composite的過程中，只有需要重新Style與Layout的Layer才需要重繪，而這些需要重繪的Layer就會被標註成綠色；以yahoo首頁為例，綠色的那條是影音列表，理當會不斷變動，因此會被Highlight為綠色。</p>\n<p>那為什麼我們需要針對這個步驟做Optimize呢？因為假如在同一層layer中，你其實只有某一個div需要re-layout，但由於是在同一個Layer，會變成整個Layer都需要重新繪製，如此一來就會增加不必要的負擔。</p>\n<p>因此我們可以在你確定會需要重繪制的div中，加入<code class=\"language-text\">will-change: transform;</code>這個屬性，告訴browser說，“欸~我知道我可能會變動喔，請不要把大家跟我視為一樣的”，這樣就能解決上述的問題。</p>\n<p>大家不妨打開自己的網站，利用Chrome的Timeline玩看看，提升頁面的渲染效率，讓我們一起追求60ps的極致快感吧！</p>\n<h2 id=\"延伸閱讀\" style=\"position:relative;\"><a href=\"#%E5%BB%B6%E4%BC%B8%E9%96%B1%E8%AE%80\" aria-label=\"延伸閱讀 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>延伸閱讀</h2>\n<ol>\n<li><a href=\"http://gent.ilcore.com/2011/03/how-not-to-trigger-layout-in-webkit.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">How not to trigger layout in webkit</a></li>\n<li><a href=\"https://developers.google.com/web/fundamentals/performance/?hl=en\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Google Web Fundamentals</a></li>\n<li><a href=\"http://www.html5rocks.com/zh/tutorials/speed/layers/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Accelerated Rendering in Chrome</a></li>\n</ol>","fields":{"slug":"front-end-kata-60-fps的快感"},"frontmatter":{"title":"Front-end kata 60fps的快感 - Browser Rendering Optimisation","date":"03-26-2016","tags":["Browser Rendering Optimisation","kata","performance"]},"timeToRead":7}},"pageContext":{"slug":"front-end-kata-60-fps的快感","prev":{"excerpt":"\"欸，你都用什麼編輯器？\"  \"小畫家啊\" 其實有蠻長一段時間都用寫code，但不管是在研究所時期或是現在工作以後，幾乎都需要連線到遠端開發機作業，即便可以用掛載磁碟的方式在本地端編輯，但若是加個VPN再參雜一些種花點心的網路... 恩，就這樣我又回到的懷抱。以往都直接抓vgod大神的設定檔來改，但你知道改code改到最後都會想說直接重寫還比較快，加上我用到的套件其實不多，所以乾脆自己設定一個。 基本上是使用Vundle這套plug-in manager 來幫我安裝所有的plugin…","html":"<blockquote>\n<p>\"欸，你都用什麼編輯器？\"  \"小畫家啊\"</p>\n</blockquote>\n<!-- more --> \n<p>其實有蠻長一段時間都用<code class=\"language-text\">sublime text</code>寫code，但不管是在研究所時期或是現在工作以後，幾乎都需要連線到遠端開發機作業，即便可以用掛載磁碟的方式在本地端編輯，但若是加個VPN再參雜一些種花點心的網路...</p>\n<p>恩，就這樣我又回到<code class=\"language-text\">vim</code>的懷抱。以往都直接抓<a href=\"https://github.com/vgod/vimrc\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">vgod</a>大神的設定檔來改，但你知道改code改到最後都會想說直接重寫還比較快，加上我用到的套件其實不多，所以乾脆自己設定一個。</p>\n<p>基本上是使用<a href=\"https://github.com/VundleVim/Vundle.vim\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Vundle</a>這套plug-in manager 來幫我安裝所有的plugin，是我目前使用起來最簡潔的工具了</p>\n<p>以下是我的<code class=\"language-text\">vimrc</code>，可以看得出來基本上是以<code class=\"language-text\">javascript</code>與<code class=\"language-text\">reactjs</code>開發為主</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">\tset nocompatible              \" be iMproved, required\n\tfiletype off                  \" required\n\n\t\" set the runtime path to include Vundle and initialize\n\tset rtp+=~/.vim/bundle/Vundle.vim\n\tcall vundle#begin()\n\n\t\" let Vundle manage Vundle, required\n\tPlugin 'VundleVim/Vundle.vim'\n\n\n\tPlugin 'rstacruz/sparkup', {'rtp': 'vim/'}\n\tPlugin 'tpope/vim-fugitive'\n\t\" vim-airline\n\tPlugin 'vim-airline/vim-airline'\n\tPlugin 'elzr/vim-json'\n\tPlugin 'pangloss/vim-javascript'\n\tPlugin 'mattn/emmet-vim'\n\tPlugin 'mxw/vim-jsx'\n\n\t\" All of your Plugins must be added before the following line\n\tcall vundle#end()            \" required\n\tfiletype plugin indent on    \" required\n\t\" To ignore plugin indent changes, instead use:\n\t\"filetype plugin on\n\t\"\n\t\" Brief help\n\t\" :PluginList       - lists configured plugins\n\t\" :PluginInstall    - installs plugins; append `!` to update or just :PluginUpdate\n\t\" :PluginSearch foo - searches for foo; append `!` to refresh local cache\n\t\" :PluginClean      - confirms removal of unused plugins; append `!` to auto-approve removal\n\t\"\n\t\" see :h vundle for more details or wiki for FAQ\n\t\" Put your non-Plugin stuff after this line\n\t\"\n\tset nocompatible\t\" not compatible with the old-fashion vi mode\n\tset bs=2\t\t\" allow backspacing over everything in insert mode\n\tset history=50\t\t\" keep 50 lines of command line history\n\tset ruler\t\t\" show the cursor position all the time\n\tset autoread\t\t\" auto read when file is changed from outside\n\tset laststatus=2\n\n\tsyntax on\n\n\tlet g:airline_powerline_fonts = 1\n\tlet g:airline_theme='solarized'\n\tsyntax enable\n\tset nu</code></pre></div>\n<p>除此之外，既然要遠端連線工作，總不能每次斷線以後，都要手動重新打開上一次工作階段，並且清除<code class=\"language-text\">temp file</code>吧！</p>\n<p>我們是程式設計師，我們很懶，所以需要更聰明的作法。因此<code class=\"language-text\">tmux</code>就很重要了！</p>\n<p><a href=\"https://tmux.github.io/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">tmux</a>是什麼呢？ 根據官方文件：</p>\n<p><em>*tmux is a terminal multiplexer. It lets you switch easily between several programs in one terminal, detach them (they keep running in the background) and reattach them to a different terminal. And do a lot more. *</em></p>\n<p>看到沒有！</p>\n<p>** <span style=\"color:red; font-style: italic;\">  Detach them (they keep running in the background) and reattach them to a different terminal </span> **  </p>\n<p>簡單來說，有了tmux，以後連線到遠端VM或是server時，就算在你開著好幾個session並且vim使用中的情況下，網路斷了或是你想拿著筆電去樓下買咖啡，回來時還是可以無痛回到你原先的工作狀態！不會因為連線中斷而需要重新initialize你原先的state。</p>\n<p>那要怎麼使用這麼好用的工具呢？</p>\n<h5 id=\"於-debian--ubuntu-linux-安裝-tmux\" style=\"position:relative;\"><a href=\"#%E6%96%BC-debian--ubuntu-linux-%E5%AE%89%E8%A3%9D-tmux\" aria-label=\"於 debian  ubuntu linux 安裝 tmux permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>於 Debian / Ubuntu Linux 安裝 Tmux</h5>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">apt-get</span> <span class=\"token function\">install</span> tmux</code></pre></div>\n<p>安裝很簡單，接著要編輯<code class=\"language-text\">tmux.conf</code>，以下是我的設定檔：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">\tunbind C-b\n\tset -g prefix ^A\n\tbind a send-prefix\n\n\t# set colors\n\tset-window-option -g window-status-current-fg blue\n\tset-window-option -g window-status-current-bg yellow\n\tset-window-option -g window-status-current-attr default\n\n\t# switch to next window\n\tunbind C-Right\n\tbind -n C-Right next-window\n\n\t# switch to previous window\n\tunbind C-Left\n\tbind -n C-Left previous-window\n\n\t# split windows like vim\n\t# vim's definition of a horizontal/vertical split is reversed from tmux's\n\tbind s split-window -v\n\tbind v split-window -h\n\n\t# move around panes with hjkl, as one would in vim after pressing ctrl-w\n\tbind h select-pane -L\n\tbind j select-pane -D\n\tbind k select-pane -U\n\tbind l select-pane -R\n\n\t# vi-style controls for copy mode\n\tsetw -g mode-keys vi\n\tunbind [\n\tbind Escape copy-mode\n\tunbind p\n\tbind p paste-buffer\n\tbind-key -t vi-copy 'v' begin-selection\n\tbind-key -t vi-copy 'y' copy-selection\n\n\tunbind ,\n\tbind A command-prompt \"rename-window '%%'\"</code></pre></div>\n<p>好，其實也很多是東抓西抓出來的，所以依照我這份設定檔，我常用的指令大概就是：</p>\n<ul>\n<li>tmux\n進入tmux session</li>\n<li>tmux attach\n在新的terminal (我推薦Iterm2) 重新attach回你之前的工作狀態(先前開啟中的tmux seesion)</li>\n<li>Crtl + A &#x26; C\n先按Crtl A，接著按下C，就會開啟一個新的tmux session</li>\n<li>Crtl + A &#x26; Shift+7\n其實就是Crtl + A接著按下 <code class=\"language-text\">&amp;</code> 符號，就可以刪除當前session</li>\n</ul>\n<p>用了tmux以後好像世界太平一片祥和風和日麗，但是事情沒有這麼簡單，當你用慣iterms方便的捲軸功能去瀏覽先前的terminal紀錄後，發現開了tmux就捲不上去時可能會很痛苦，不過沒關係，還是有折衷方案！</p>\n<ul>\n<li>Crtl + A &#x26; pageUp or up Arrow\n讓你可以往上或往下去terminal紀錄</li>\n</ul>\n<p>好的，老實說這篇只是我想記錄一下我的記錄檔案...\n所以如果需要好好學習tmux的人，可以移駕 <a href=\"https://blog.longwin.com.tw/2011/04/tmux-learn-screen-config-2011/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Tsung's Blog</a></p>","id":"db94b934-fb2a-535d-990a-3fbbcdcc2d68","fields":{"slug":"vimrc-tmux設定"},"frontmatter":{"date":"2016-03-05T11:22:33.000Z","title":"vimrc & tmux 設定","tags":["vim","tmux"],"type":"tech","slug":"vimrc-tmux設定"},"timeToRead":4},"next":{"excerpt":"\"欸，IOT好像講太久了，VR也是，不趕快弄個新的不行啊！\"\n\t\"Hmmm...Alpha Go剛打敗人類，不然趁機推個Bot吧\"","html":"<blockquote>\n<p>\"欸，IOT好像講太久了，VR也是，不趕快弄個新的不行啊！\"\n\"Hmmm...Alpha Go剛打敗人類，不然趁機推個Bot吧\"</p>\n</blockquote>\n<!-- more -->\n<p>最近Bot好像很夯，FB也在幾天前的F8大會上推出Messenger API，讓擁有粉絲頁的店家、企業、或是個人，能夠製作出Chat Bot來與使用者互動。事實上像是Slack、HipChat、telegram等通訊軟體都早已有類似的Bot api可以提供使用，並且在設計上跟Facebook現階段推出的 API 其實大同小異，甚至也已經有人將它整進Hubot framework中 <a href=\"https://github.com/chen-ye/hubot-fb\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">hubot-fb</a>，連所謂的 <a href=\"https://medium.com/@tomazstolfa/the-future-of-conversational-ui-belongs-to-hybrid-interfaces-8a228de0bdb5#.b0tcmb607\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">CUI - Conversational User Interface</a> 都出現了。</p>\n<p>對我來說，Chat Bot也只是另一種方式來解決使用者的問題，另一種相對新穎的媒介，找到痛點，並對症下藥這件事情是不會改變的！</p>\n<p>好，扯遠了。Facebook Messenger最大的優勢除了FB本身龐大的使用者外，還有粉絲專頁的功能可以操作，如同 Mark Zuckerberg 在F8 Keynote中提到的例子一樣，背後隱藏的商機與可能性非常大，因此還是有必要來玩一下Messenger API。這邊希望簡單記錄與並以中文說明如何產生你的第一個Messenger Bot，讓你夜深寂寞時能有人陪你聊天...</p>\n<p>值得一提的是，Facebook developer doc上面的說明算是非常清楚，需要完整文件支援的話可以移駕至此 <a href=\"https://developers.facebook.com/docs/messenger-platform/quickstart\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">FB messenger-platform doc</a></p>\n<h2 id=\"step-1---創建facebook-應用程式與facebook粉絲專頁\" style=\"position:relative;\"><a href=\"#step-1---%E5%89%B5%E5%BB%BAfacebook-%E6%87%89%E7%94%A8%E7%A8%8B%E5%BC%8F%E8%88%87facebook%E7%B2%89%E7%B5%B2%E5%B0%88%E9%A0%81\" aria-label=\"step 1   創建facebook 應用程式與facebook粉絲專頁 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Step 1 - 創建Facebook 應用程式與Facebook粉絲專頁</h2>\n<p>還沒有在Facebook上面創建過應用程式的讀者，可以先連結到 <a href=\"https://developers.facebook.com/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://developers.facebook.com/</a>\n進去後會看到右上角會有<strong>我的應用程式</strong>可以選擇</p>\n<p><img src=\"/image/fbdeveloper.png\" alt=\"FB developer\" title=\"FB developer\"></p>\n<p>選擇<strong>新增應用程式</strong>後，理論上會需要填寫一些基本資訊，必要填寫的有<strong>顯示名稱</strong>, <strong>聯絡電子郵件</strong> 與 <strong>網站網址</strong>\n這邊要注意一下，基本上你如果想要用Messenger API，你勢必會需要有一個server來養你的bot，若不想污染你自己目前的server環境，就創建一個新的吧！FB上的範例多數是以JS為主，當然你可以自行選用慣用的環境。</p>\n<p><img src=\"/image/fbapp-apply.png\" alt=\"FB App 申請\" title=\"FB App 申請\"></p>\n<p>接著看向左邊的Menu，在最下方地方有個Messenger，點選後會進入以下頁面</p>\n<p><img src=\"/image/messenger.png\" alt=\"Messenger 申請\" title=\"Messenger 申請\"></p>\n<p>重點有兩個地方，第一個是你必須要選擇一個粉絲專頁，在這邊選定好粉絲專頁後，後面產生的Token（權杖）會用來將你的app與粉絲專頁綁定，之後的messenger要透過此Token才能順利執行。第二個Webhooks的步驟下面會談到。</p>\n<p>創建粉絲專頁非常簡單，簡單到多放一張圖都是多餘，因此我們直接跳往下個步驟。\n<img src=\"/image/token.png\" alt=\"粉絲專頁選好後會出現Token\" title=\"Token\"></p>\n<h2 id=\"step-2---set-up-webhook\" style=\"position:relative;\"><a href=\"#step-2---set-up-webhook\" aria-label=\"step 2   set up webhook permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Step 2 - Set up Webhook</h2>\n<p>當你選定好粉絲專頁後就要設定你的webhook，這邊就需要開始寫點code了！\n但先別急著動手！當你點選set up webhook後，會彈出一個視窗：</p>\n<p><img src=\"/image/webhook.png\" alt=\"Webhook setup\" title=\"Webhook setup\"></p>\n<p>這邊的url就要填寫你的server，記得要填寫適當的route，以FB的範例程式為例，如果你希望之後的bot api都走/webhook這個route當作進入點，那這邊的url可能就要填寫 <code class=\"language-text\">https://www.mybot.com/webhook/</code>\n這邊另外要注意一點，你的server必須要提供https，如果你跟筆者一樣先前沒有設定過ssl的話，推薦<a href=\"https://www.cloudflare.com/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">cloudflare</a>的free plan或是前陣子很紅的<a href=\"https://letsencrypt.org/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Let's encrypt</a></p>\n<p>當一切準備就緒後，把你server的route添加以下的程式：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascriptroutes.js\"><pre class=\"language-javascriptroutes.js\"><code class=\"language-javascriptroutes.js\">\t\tapp.get(&#39;/webhook/&#39;, function (req, res) {\n\t\t\tif (req.query[&#39;hub.verify_token&#39;] === &#39;&lt;validation_token&gt;&#39;) {\n\t\t\t\tres.send(req.query[&#39;hub.challenge&#39;]);\n\t\t\t}\n\t\t\tres.send(&#39;Error, wrong validation token&#39;);\n\t\t})</code></pre></div>\n<p>若你跟我一樣習慣把route分開，當然就會變成以下這樣，而webhook url 就是 <code class=\"language-text\">https://www.mybot.com/fbbot/</code></p>\n<div class=\"gatsby-highlight\" data-language=\"javascriptroutes/fbbot.js\"><pre class=\"language-javascriptroutes/fbbot.js\"><code class=\"language-javascriptroutes/fbbot.js\">\t\troute.get(&#39;/&#39;, function (req, res) {\n\t\t\tif (req.query[&#39;hub.verify_token&#39;] === &#39;&lt;validation_token&gt;&#39;) {\n\t\t\t\tres.send(req.query[&#39;hub.challenge&#39;]);\n\t\t\t}\n\t\t\tres.send(&#39;Error, wrong validation token&#39;);\n\t\t})</code></pre></div>\n<p>這邊的<code class=\"language-text\">validation_token</code>就是上圖中的<strong>驗證權杖</strong>，基本上隨便你填寫什麼都可以。</p>\n<p>當你在server端加上route，並且把他填寫到上面的url欄位後，記得將下方的<strong>訂閱欄位</strong>的選項都打勾，不然你就沒辦法傳送訊息。接著就可以按下save，FB會emit一個get request去驗證你的webhook，成功後該區塊就會變成：</p>\n<p><img src=\"/image/webhooksuccess.png\" alt=\"Webhook successful\" title=\"Webhook successful\"></p>\n<h2 id=\"step-3---subscribe-the-app-to-the-page\" style=\"position:relative;\"><a href=\"#step-3---subscribe-the-app-to-the-page\" aria-label=\"step 3   subscribe the app to the page permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Step 3 - Subscribe the App to the Page</h2>\n<p>記得步驟一中我們有設定好粉絲專頁，並取得Token嗎？現在就需要利用該Token來讓我們的App與粉絲專頁進行綁定，只需要一行指令：\n<code class=\"language-text\">curl -ik -X POST \"https://graph.facebook.com/v2.6/me/subscribed_apps?access_token=&lt;token>\"</code></p>\n<p>如果進行到這邊都沒問題的話，就可以進入重頭戲了。</p>\n<h2 id=\"step-4---send-a-text--receive-message\" style=\"position:relative;\"><a href=\"#step-4---send-a-text--receive-message\" aria-label=\"step 4   send a text  receive message permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Step 4 - Send a text &#x26; Receive Message</h2>\n<p>Message的傳送是透過<code class=\"language-text\">POST</code>，我們再度新增一個route在你的webhook底下：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascriptroutes/fbbot.js\"><pre class=\"language-javascriptroutes/fbbot.js\"><code class=\"language-javascriptroutes/fbbot.js\">fbbot.post(&#39;/&#39;, function (req, res) {\n  messaging_events = req.body.entry[0].messaging;\n  for (i = 0; i &lt; messaging_events.length; i++) {\n    event = req.body.entry[0].messaging[i];\n    sender = event.sender.id;\n    if (event.message &amp;&amp; event.message.text) {\n      text = event.message.text;\n      // Handle a text message from this sender\n    }\n  }\n  res.sendStatus(200);\n});</code></pre></div>\n<p>這樣你就能在server上接收到別人傳送給你的粉絲專頁的訊息。</p>\n<p>接著我們撰寫個簡單的<code class=\"language-text\">sendTextMessage Method</code>：\n(FB的範例是include request這個http client module，你可以用你自己習慣的方式)</p>\n<div class=\"gatsby-highlight\" data-language=\"javascriptsendtextmessage.js\"><pre class=\"language-javascriptsendtextmessage.js\"><code class=\"language-javascriptsendtextmessage.js\">var token = &quot;&lt;page_access_token&gt;&quot;;\nvar request = require(&#39;request&#39;);\n\nfunction sendTextMessage(sender, text) {\n  messageData = {\n    text:text\n  }\n  request({\n    url: &#39;https://graph.facebook.com/v2.6/me/messages&#39;,\n    qs: {access_token:token},\n    method: &#39;POST&#39;,\n    json: {\n      recipient: {id:sender},\n      message: messageData,\n    }\n  }, function(error, response, body) {\n    if (error) {\n      console.log(&#39;Error sending message: &#39;, error);\n    } else if (response.body.error) {\n      console.log(&#39;Error: &#39;, response.body.error);\n    }\n  });\n}</code></pre></div>\n<p>接著我們把這個Method放到前面的<code class=\"language-text\">POST</code>處理中：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascriptroutes/fbbot.js\"><pre class=\"language-javascriptroutes/fbbot.js\"><code class=\"language-javascriptroutes/fbbot.js\">fbbot.post(&#39;/&#39;, function (req, res) {\n  messaging_events = req.body.entry[0].messaging;\n  for (i = 0; i &lt; messaging_events.length; i++) {\n    event = req.body.entry[0].messaging[i];\n    sender = event.sender.id;\n    if (event.message &amp;&amp; event.message.text) {\n      text = event.message.text;\n      // Handle a text message from this sender\n      sendTextMessage(sender, &quot;Text received, echo: &quot;+ text.substring(0, 200));\n    }\n  }\n  res.sendStatus(200);\n});</code></pre></div>\n<p>接著去到粉絲專頁傳訊息看看吧！</p>\n<p><img src=\"/image/echo-robot.png\" alt=\"Echo Robot\" title=\"Echo Robot\"></p>\n<p>Yeah! you just build your first own echo robot!</p>\n<h2 id=\"總結\" style=\"position:relative;\"><a href=\"#%E7%B8%BD%E7%B5%90\" aria-label=\"總結 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>總結</h2>\n<p>目前Messenger API的功能還很少，且需要許多認證才能讓你的bot正式使用，但我想之後一定會出現更簡易的設定方式，讓一般粉絲頁不用撰寫程式碼即可擁有自己的bot，否則也會有 Bot版本的 Wix 出現吧！</p>\n<p>其實Bot說穿了就是低成本、自動化去解決問題，背後的AI、NLP、ML等等才是重點！不過接下來我應該會先繼續研究Messnger API，並用Hubot adapter開發幾個slack與telegram bot玩玩！或許加上一些NLP處理～</p>","id":"35e9daa0-d17c-57af-9006-19f3f458c0a1","fields":{"slug":"super-easy-messenger-api"},"frontmatter":{"date":"2016-04-17T12:54:13.000Z","title":"超簡易 Messenger API 初探","tags":["messenger","api","facebook"],"type":"tech","slug":"super-easy-messenger-api"},"timeToRead":5},"type":"tech"}},"staticQueryHashes":["2123680655"]}